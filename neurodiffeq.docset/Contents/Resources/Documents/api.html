
<!DOCTYPE html>

<html class="writer-html5" lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>API Reference — neurodiffeq  documentation</title>
<link href="_static/css/theme.css" rel="stylesheet" type="text/css"/>
<link href="_static/pygments.css" rel="stylesheet" type="text/css"/>
<link href="_static/custom.css" rel="stylesheet" type="text/css"/>
<!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
<script data-url_root="./" id="documentation_options" src="_static/documentation_options.js" type="text/javascript"></script>
<script src="_static/jquery.js"></script>
<script src="_static/underscore.js"></script>
<script src="_static/doctools.js"></script>
<script src="_static/language_data.js"></script>
<script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
<script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
<script src="_static/js/theme.js" type="text/javascript"></script>
<link href="genindex.html" rel="index" title="Index"/>
<link href="search.html" rel="search" title="Search"/>
<link href="how.html" rel="next" title="How Does It Work?"/>
<link href="advanced.html" rel="prev" title="Advanced Uses"/>
</head>
<body class="wy-body-for-nav">
<div class="wy-grid-for-nav">
<nav class="wy-nav-side" data-toggle="wy-nav-shift">
<div class="wy-side-scroll">
<div class="wy-side-nav-search">
<a alt="Documentation Home" class="icon icon-home" href="index.html"> neurodiffeq
          

          
          </a>
<div role="search">
<form action="search.html" class="wy-form" id="rtd-search-form" method="get">
<input name="q" placeholder="Search docs" type="text"/>
<input name="check_keywords" type="hidden" value="yes"/>
<input name="area" type="hidden" value="default"/>
</form>
</div>
</div>
<div aria-label="main navigation" class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation">
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="getstart.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="advanced.html">Advanced Uses</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">API Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#module-neurodiffeq.neurodiffeq"><cite>neurodiffeq.neurodiffeq</cite></a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-neurodiffeq.networks"><cite>neurodiffeq.networks</cite></a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-neurodiffeq.conditions"><cite>neurodiffeq.conditions</cite></a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-neurodiffeq.ode"><cite>neurodiffeq.ode</cite></a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-neurodiffeq.pde"><cite>neurodiffeq.pde</cite></a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-neurodiffeq.pde_spherical"><cite>neurodiffeq.pde_spherical</cite></a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-neurodiffeq.temporal"><cite>neurodiffeq.temporal</cite></a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-neurodiffeq.function_basis"><cite>neurodiffeq.function_basis</cite></a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-neurodiffeq.generators"><cite>neurodiffeq.generators</cite></a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-neurodiffeq.operators"><cite>neurodiffeq.operators</cite></a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-neurodiffeq.utils"><cite>neurodiffeq.utils</cite></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="how.html">How Does It Work?</a></li>
</ul>
</div>
</div>
</nav>
<section class="wy-nav-content-wrap" data-toggle="wy-nav-shift">
<nav aria-label="top navigation" class="wy-nav-top">
<i class="fa fa-bars" data-toggle="wy-nav-top"></i>
<a href="index.html">neurodiffeq</a>
</nav>
<div class="wy-nav-content">
<div class="rst-content">
<div aria-label="breadcrumbs navigation" role="navigation">
<ul class="wy-breadcrumbs">
<li><a class="icon icon-home" href="index.html"></a> »</li>
<li>API Reference</li>
<li class="wy-breadcrumbs-aside">
<a href="_sources/api.rst.txt" rel="nofollow"> View page source</a>
</li>
</ul>
<hr/>
</div>
<div class="document" itemscope="itemscope" itemtype="http://schema.org/Article" role="main">
<div itemprop="articleBody">
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<div class="section" id="api-reference">
<h1>API Reference<a class="headerlink" href="#api-reference" title="Permalink to this headline">¶</a></h1>
<div class="section" id="module-neurodiffeq.neurodiffeq">
<span id="neurodiffeq-neurodiffeq"></span><h2><a name="//apple_ref/cpp/Module/neurodiffeq.neurodiffeq"></a><cite>neurodiffeq.neurodiffeq</cite><a class="headerlink" href="#module-neurodiffeq.neurodiffeq" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="neurodiffeq.neurodiffeq.diff"><a name="//apple_ref/cpp/Function/neurodiffeq.neurodiffeq.diff"></a>
<code class="sig-prename descclassname">neurodiffeq.neurodiffeq.</code><code class="sig-name descname">diff</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">t</span></em>, <em class="sig-param"><span class="n">order</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">shape_check</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.neurodiffeq.diff" title="Permalink to this definition">¶</a></dt>
<dd><p>The derivative of a variable with respect to another.
Currently, <code class="docutils literal notranslate"><span class="pre">diff</span></code> defaults to <code class="docutils literal notranslate"><span class="pre">unsafe_diff</span></code>, but in a future release, it will default to <code class="docutils literal notranslate"><span class="pre">safe_diff</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<cite>torch.Tensor</cite>) – The <span class="math notranslate nohighlight">\(x\)</span> in <span class="math notranslate nohighlight">\(\displaystyle\frac{\partial x}{\partial t}\)</span>.</p></li>
<li><p><strong>t</strong> (<cite>torch.Tensor</cite>) – The <span class="math notranslate nohighlight">\(t\)</span> in <span class="math notranslate nohighlight">\(\displaystyle\frac{\partial x}{\partial t}\)</span>.</p></li>
<li><p><strong>order</strong> (<em>int</em>) – The order of the derivative, defaults to 1.</p></li>
<li><p><strong>shape_check</strong> (<em>bool</em>) – Whether to perform shape checking or not, defaults to False (to be changed in v0.2.0).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The derivative.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>torch.Tensor</cite></p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt id="neurodiffeq.neurodiffeq.safe_diff"><a name="//apple_ref/cpp/Function/neurodiffeq.neurodiffeq.safe_diff"></a>
<code class="sig-prename descclassname">neurodiffeq.neurodiffeq.</code><code class="sig-name descname">safe_diff</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">t</span></em>, <em class="sig-param"><span class="n">order</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.neurodiffeq.safe_diff" title="Permalink to this definition">¶</a></dt>
<dd><p>The derivative of a variable with respect to another.
Both tensors must have a shape of (n_samples, 1)
See <a class="reference external" href="https://github.com/odegym/neurodiffeq/issues/63#issuecomment-718007133">this issue comment</a> for details</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<cite>torch.Tensor</cite>) – The <span class="math notranslate nohighlight">\(x\)</span> in <span class="math notranslate nohighlight">\(\displaystyle\frac{\partial x}{\partial t}\)</span>.</p></li>
<li><p><strong>t</strong> (<cite>torch.Tensor</cite>) – The <span class="math notranslate nohighlight">\(t\)</span> in <span class="math notranslate nohighlight">\(\displaystyle\frac{\partial x}{\partial t}\)</span>.</p></li>
<li><p><strong>order</strong> (<em>int</em>) – The order of the derivative, defaults to 1.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The derivative.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>torch.Tensor</cite></p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt id="neurodiffeq.neurodiffeq.unsafe_diff"><a name="//apple_ref/cpp/Function/neurodiffeq.neurodiffeq.unsafe_diff"></a>
<code class="sig-prename descclassname">neurodiffeq.neurodiffeq.</code><code class="sig-name descname">unsafe_diff</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">t</span></em>, <em class="sig-param"><span class="n">order</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.neurodiffeq.unsafe_diff" title="Permalink to this definition">¶</a></dt>
<dd><p>The derivative of a variable with respect to another.
While there’s no requirement for shapes, errors could occur in some cases.
See <a class="reference external" href="https://github.com/odegym/neurodiffeq/issues/63#issue-719436650">this issue</a> for details</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<cite>torch.Tensor</cite>) – The <span class="math notranslate nohighlight">\(x\)</span> in <span class="math notranslate nohighlight">\(\displaystyle\frac{\partial x}{\partial t}\)</span>.</p></li>
<li><p><strong>t</strong> (<cite>torch.Tensor</cite>) – The <span class="math notranslate nohighlight">\(t\)</span> in <span class="math notranslate nohighlight">\(\displaystyle\frac{\partial x}{\partial t}\)</span>.</p></li>
<li><p><strong>order</strong> (<em>int</em>) – The order of the derivative, defaults to 1.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The derivative.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>torch.Tensor</cite></p>
</dd>
</dl>
</dd></dl>
</div>
<div class="section" id="module-neurodiffeq.networks">
<span id="neurodiffeq-networks"></span><h2><a name="//apple_ref/cpp/Module/neurodiffeq.networks"></a><cite>neurodiffeq.networks</cite><a class="headerlink" href="#module-neurodiffeq.networks" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-neurodiffeq.conditions">
<span id="neurodiffeq-conditions"></span><h2><a name="//apple_ref/cpp/Module/neurodiffeq.conditions"></a><cite>neurodiffeq.conditions</cite><a class="headerlink" href="#module-neurodiffeq.conditions" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="neurodiffeq.conditions.BaseCondition"><a name="//apple_ref/cpp/Class/neurodiffeq.conditions.BaseCondition"></a>
<em class="property">class </em><code class="sig-prename descclassname">neurodiffeq.conditions.</code><code class="sig-name descname">BaseCondition</code><a class="headerlink" href="#neurodiffeq.conditions.BaseCondition" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Base class for all conditions.</p>
<p>A condition is a tool to <cite>re-parameterize</cite> the output(s) of a neural network.
such that the re-parameterized output(s) will automatically satisfy initial conditions (ICs)
and boundary conditions (BCs) of the PDEs/ODEs that are being solved.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>The nouns <em>(re-)parameterization</em> and <em>condition</em> are used interchangeably in the documentation and library.</p></li>
<li><p>The verbs <em>(re-)parameterize</em> and <em>enforce</em> are different in that:</p>
<ul>
<li><p><em>(re)parameterize</em> is said of network outputs;</p></li>
<li><p><em>enforce</em> is said of networks themselves.</p></li>
</ul>
</li>
</ul>
</div>
<dl class="py method">
<dt id="neurodiffeq.conditions.BaseCondition.enforce"><a name="//apple_ref/cpp/Method/neurodiffeq.conditions.BaseCondition.enforce"></a>
<code class="sig-name descname">enforce</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">net</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">coordinates</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.conditions.BaseCondition.enforce" title="Permalink to this definition">¶</a></dt>
<dd><p>Enforces this condition on a network.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>net</strong> (<cite>torch.nn.Module</cite>) – The network whose output is to be re-parameterized.</p></li>
<li><p><strong>coordinates</strong> (<cite>torch.Tensor</cite>) – Inputs of the neural network.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The re-parameterized output, where the condition is automatically satisfied.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>torch.Tensor</cite></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="neurodiffeq.conditions.BaseCondition.parameterize"><a name="//apple_ref/cpp/Method/neurodiffeq.conditions.BaseCondition.parameterize"></a>
<code class="sig-name descname">parameterize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">output_tensor</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">input_tensors</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.conditions.BaseCondition.parameterize" title="Permalink to this definition">¶</a></dt>
<dd><p>Re-parameterizes output(s) of a network.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>output_tensor</strong> (<cite>torch.Tensor</cite>) – Output of the neural network.</p></li>
<li><p><strong>input_tensors</strong> (<cite>torch.Tensor</cite>) – Inputs to the neural network; i.e., sampled coordinates; i.e., independent variables.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The re-parameterized output of the network.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>torch.Tensor</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is <strong>abstract</strong> for BaseCondition</p>
</div>
</dd></dl>
<dl class="py method">
<dt id="neurodiffeq.conditions.BaseCondition.set_impose_on"><a name="//apple_ref/cpp/Method/neurodiffeq.conditions.BaseCondition.set_impose_on"></a>
<code class="sig-name descname">set_impose_on</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ith_unit</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.conditions.BaseCondition.set_impose_on" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>[DEPRECATED]</strong> When training several functions with a single, multi-output network, this method is called
(by a <cite>Solver</cite> class or a <cite>solve</cite> function) to keep track of which output is being parameterized.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>ith_unit</strong> (<em>int</em>) – The index of network output to be parameterized.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is deprecated and retained for backward compatibility only. Users interested in enforcing
conditions on multi-output networks should consider using a <code class="docutils literal notranslate"><span class="pre">neurodiffeq.conditions.EnsembleCondition</span></code>.</p>
</div>
</dd></dl>
</dd></dl>
<dl class="py class">
<dt id="neurodiffeq.conditions.DirichletBVP"><a name="//apple_ref/cpp/Class/neurodiffeq.conditions.DirichletBVP"></a>
<em class="property">class </em><code class="sig-prename descclassname">neurodiffeq.conditions.</code><code class="sig-name descname">DirichletBVP</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">t_0</span></em>, <em class="sig-param"><span class="n">x_0</span></em>, <em class="sig-param"><span class="n">t_1</span></em>, <em class="sig-param"><span class="n">x_1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.conditions.DirichletBVP" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#neurodiffeq.conditions.BaseCondition" title="neurodiffeq.conditions.BaseCondition"><code class="xref py py-class docutils literal notranslate"><span class="pre">neurodiffeq.conditions.BaseCondition</span></code></a></p>
<p>A double-ended Dirichlet boundary condition:
<span class="math notranslate nohighlight">\(x(t_0)=x_0\)</span> and <span class="math notranslate nohighlight">\(x(t_1)=x_1\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>t_0</strong> (<em>float</em>) – The initial time.</p></li>
<li><p><strong>t_1</strong> (<em>float</em>) – The final time.</p></li>
<li><p><strong>x_0</strong> (<em>float</em>) – The initial value of <span class="math notranslate nohighlight">\(x\)</span>. <span class="math notranslate nohighlight">\(x(t_0)=x_0\)</span>.</p></li>
<li><p><strong>x_1</strong> (<em>float</em>) – The initial value of <span class="math notranslate nohighlight">\(x\)</span>. <span class="math notranslate nohighlight">\(x(t_1)=x_1\)</span>.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="neurodiffeq.conditions.DirichletBVP.enforce"><a name="//apple_ref/cpp/Method/neurodiffeq.conditions.DirichletBVP.enforce"></a>
<code class="sig-name descname">enforce</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">net</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">coordinates</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.conditions.DirichletBVP.enforce" title="Permalink to this definition">¶</a></dt>
<dd><p>Enforces this condition on a network.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>net</strong> (<cite>torch.nn.Module</cite>) – The network whose output is to be re-parameterized.</p></li>
<li><p><strong>coordinates</strong> (<cite>torch.Tensor</cite>) – Inputs of the neural network.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The re-parameterized output, where the condition is automatically satisfied.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>torch.Tensor</cite></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="neurodiffeq.conditions.DirichletBVP.parameterize"><a name="//apple_ref/cpp/Method/neurodiffeq.conditions.DirichletBVP.parameterize"></a>
<code class="sig-name descname">parameterize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">output_tensor</span></em>, <em class="sig-param"><span class="n">t</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.conditions.DirichletBVP.parameterize" title="Permalink to this definition">¶</a></dt>
<dd><p>Re-parameterizes outputs such that the Dirichlet condition is satisfied on both ends of the domain.</p>
<p>The re-parameterization is
<span class="math notranslate nohighlight">\(\displaystyle x(t)=(1-\tilde{t})x_0+\tilde{t}x_1+\left(1-e^{(1-\tilde{t})\tilde{t}}\right)\mathrm{ANN}(t)\)</span>,
where <span class="math notranslate nohighlight">\(\displaystyle \tilde{t} = \frac{t-t_0}{t_1-t_0}\)</span> and <span class="math notranslate nohighlight">\(\mathrm{ANN}\)</span> is the neural network.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>output_tensor</strong> (<cite>torch.Tensor</cite>) – Output of the neural network.</p></li>
<li><p><strong>t</strong> (<cite>torch.Tensor</cite>) – Input to the neural network; i.e., sampled time-points or another independent variable.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The re-parameterized output of the network.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>torch.Tensor</cite></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="neurodiffeq.conditions.DirichletBVP.set_impose_on"><a name="//apple_ref/cpp/Method/neurodiffeq.conditions.DirichletBVP.set_impose_on"></a>
<code class="sig-name descname">set_impose_on</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ith_unit</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.conditions.DirichletBVP.set_impose_on" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>[DEPRECATED]</strong> When training several functions with a single, multi-output network, this method is called
(by a <cite>Solver</cite> class or a <cite>solve</cite> function) to keep track of which output is being parameterized.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>ith_unit</strong> (<em>int</em>) – The index of network output to be parameterized.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is deprecated and retained for backward compatibility only. Users interested in enforcing
conditions on multi-output networks should consider using a <code class="docutils literal notranslate"><span class="pre">neurodiffeq.conditions.EnsembleCondition</span></code>.</p>
</div>
</dd></dl>
</dd></dl>
<dl class="py class">
<dt id="neurodiffeq.conditions.DirichletBVP2D"><a name="//apple_ref/cpp/Class/neurodiffeq.conditions.DirichletBVP2D"></a>
<em class="property">class </em><code class="sig-prename descclassname">neurodiffeq.conditions.</code><code class="sig-name descname">DirichletBVP2D</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x_min</span></em>, <em class="sig-param"><span class="n">x_min_val</span></em>, <em class="sig-param"><span class="n">x_max</span></em>, <em class="sig-param"><span class="n">x_max_val</span></em>, <em class="sig-param"><span class="n">y_min</span></em>, <em class="sig-param"><span class="n">y_min_val</span></em>, <em class="sig-param"><span class="n">y_max</span></em>, <em class="sig-param"><span class="n">y_max_val</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.conditions.DirichletBVP2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#neurodiffeq.conditions.BaseCondition" title="neurodiffeq.conditions.BaseCondition"><code class="xref py py-class docutils literal notranslate"><span class="pre">neurodiffeq.conditions.BaseCondition</span></code></a></p>
<p>An Dirichlet boundary condition on the boundary of <span class="math notranslate nohighlight">\([x_0, x_1] \times [y_0, y_1]\)</span>, where</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(u(x_0, y) = f_0(y)\)</span>;</p></li>
<li><p><span class="math notranslate nohighlight">\(u(x_1, y) = f_1(y)\)</span>;</p></li>
<li><p><span class="math notranslate nohighlight">\(u(x, y_0) = g_0(x)\)</span>;</p></li>
<li><p><span class="math notranslate nohighlight">\(u(x, y_1) = g_1(x)\)</span>.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x_min</strong> (<em>float</em>) – The lower bound of x, the <span class="math notranslate nohighlight">\(x_0\)</span>.</p></li>
<li><p><strong>x_min_val</strong> (<em>callable</em>) – The boundary value on <span class="math notranslate nohighlight">\(x = x_0\)</span>, i.e. <span class="math notranslate nohighlight">\(f_0(y)\)</span>.</p></li>
<li><p><strong>x_max</strong> (<em>float</em>) – The upper bound of x, the <span class="math notranslate nohighlight">\(x_1\)</span>.</p></li>
<li><p><strong>x_max_val</strong> (<em>callable</em>) – The boundary value on <span class="math notranslate nohighlight">\(x = x_1\)</span>, i.e. <span class="math notranslate nohighlight">\(f_1(y)\)</span>.</p></li>
<li><p><strong>y_min</strong> (<em>float</em>) – The lower bound of y, the <span class="math notranslate nohighlight">\(y_0\)</span>.</p></li>
<li><p><strong>y_min_val</strong> (<em>callable</em>) – The boundary value on <span class="math notranslate nohighlight">\(y = y_0\)</span>, i.e. <span class="math notranslate nohighlight">\(g_0(x)\)</span>.</p></li>
<li><p><strong>y_max</strong> (<em>float</em>) – The upper bound of y, the <span class="math notranslate nohighlight">\(y_1\)</span>.</p></li>
<li><p><strong>y_max_val</strong> (<em>callable</em>) – The boundary value on <span class="math notranslate nohighlight">\(y = y_1\)</span>, i.e. <span class="math notranslate nohighlight">\(g_1(x)\)</span>.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="neurodiffeq.conditions.DirichletBVP2D.enforce"><a name="//apple_ref/cpp/Method/neurodiffeq.conditions.DirichletBVP2D.enforce"></a>
<code class="sig-name descname">enforce</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">net</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">coordinates</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.conditions.DirichletBVP2D.enforce" title="Permalink to this definition">¶</a></dt>
<dd><p>Enforces this condition on a network.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>net</strong> (<cite>torch.nn.Module</cite>) – The network whose output is to be re-parameterized.</p></li>
<li><p><strong>coordinates</strong> (<cite>torch.Tensor</cite>) – Inputs of the neural network.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The re-parameterized output, where the condition is automatically satisfied.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>torch.Tensor</cite></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="neurodiffeq.conditions.DirichletBVP2D.parameterize"><a name="//apple_ref/cpp/Method/neurodiffeq.conditions.DirichletBVP2D.parameterize"></a>
<code class="sig-name descname">parameterize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">output_tensor</span></em>, <em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.conditions.DirichletBVP2D.parameterize" title="Permalink to this definition">¶</a></dt>
<dd><p>Re-parameterizes outputs such that the Dirichlet condition is satisfied on all four sides of the domain.</p>
<p>The re-parameterization is
<span class="math notranslate nohighlight">\(\displaystyle u(x,y)=A(x,y)
+\tilde{x}\big(1-\tilde{x}\big)\tilde{y}\big(1-\tilde{y}\big)\mathrm{ANN}(x,y)\)</span>, where</p>
<p><span class="math notranslate nohighlight">\(\displaystyle \begin{align*}
A(x,y)=&amp;\big(1-\tilde{x}\big)f_0(y)+\tilde{x}f_1(y) \\
&amp;+\big(1-\tilde{y}\big)\Big(g_0(x)-\big(1-\tilde{x}\big)g_0(x_0)+\tilde{x}g_0(x_1)\Big) \\
&amp;+\tilde{y}\Big(g_1(x)-\big(1-\tilde{x}\big)g_1(x_0)+\tilde{x}g_1(x_1)\Big)
\end{align*}\)</span></p>
<p><span class="math notranslate nohighlight">\(\displaystyle\tilde{x}=\frac{x-x_0}{x_1-x_0}\)</span>,</p>
<p><span class="math notranslate nohighlight">\(\displaystyle\tilde{y}=\frac{y-y_0}{y_1-y_0}\)</span>,</p>
<p>and <span class="math notranslate nohighlight">\(\mathrm{ANN}\)</span> is the neural network.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>output_tensor</strong> (<cite>torch.Tensor</cite>) – Output of the neural network.</p></li>
<li><p><strong>x</strong> (<cite>torch.Tensor</cite>) – <span class="math notranslate nohighlight">\(x\)</span>-coordinates of inputs to the neural network; i.e., the sampled <span class="math notranslate nohighlight">\(x\)</span>-coordinates</p></li>
<li><p><strong>y</strong> (<cite>torch.Tensor</cite>) – <span class="math notranslate nohighlight">\(y\)</span>-coordinates of inputs to the neural network; i.e., the sampled <span class="math notranslate nohighlight">\(y\)</span>-coordinates</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The re-parameterized output of the network.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>torch.Tensor</cite></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="neurodiffeq.conditions.DirichletBVP2D.set_impose_on"><a name="//apple_ref/cpp/Method/neurodiffeq.conditions.DirichletBVP2D.set_impose_on"></a>
<code class="sig-name descname">set_impose_on</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ith_unit</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.conditions.DirichletBVP2D.set_impose_on" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>[DEPRECATED]</strong> When training several functions with a single, multi-output network, this method is called
(by a <cite>Solver</cite> class or a <cite>solve</cite> function) to keep track of which output is being parameterized.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>ith_unit</strong> (<em>int</em>) – The index of network output to be parameterized.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is deprecated and retained for backward compatibility only. Users interested in enforcing
conditions on multi-output networks should consider using a <code class="docutils literal notranslate"><span class="pre">neurodiffeq.conditions.EnsembleCondition</span></code>.</p>
</div>
</dd></dl>
</dd></dl>
<dl class="py class">
<dt id="neurodiffeq.conditions.DirichletBVPSpherical"><a name="//apple_ref/cpp/Class/neurodiffeq.conditions.DirichletBVPSpherical"></a>
<em class="property">class </em><code class="sig-prename descclassname">neurodiffeq.conditions.</code><code class="sig-name descname">DirichletBVPSpherical</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">r_0</span></em>, <em class="sig-param"><span class="n">f</span></em>, <em class="sig-param"><span class="n">r_1</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">g</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.conditions.DirichletBVPSpherical" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#neurodiffeq.conditions.BaseCondition" title="neurodiffeq.conditions.BaseCondition"><code class="xref py py-class docutils literal notranslate"><span class="pre">neurodiffeq.conditions.BaseCondition</span></code></a></p>
<p>The Dirichlet boundary condition for the interior and exterior boundary of the sphere,
where the interior boundary is not necessarily a point. The conditions are:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(u(r_0,\theta,\phi)=f(\theta,\phi)\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(u(r_1,\theta,\phi)=g(\theta,\phi)\)</span></p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>r_0</strong> (<em>float</em>) – The radius of the interior boundary. When <span class="math notranslate nohighlight">\(r_0 = 0\)</span>, the interior boundary collapses to a single point (center of the ball).</p></li>
<li><p><strong>f</strong> (<em>callable</em>) – The value of <span class="math notranslate nohighlight">\(u\)</span> on the interior boundary. <span class="math notranslate nohighlight">\(u(r_0, \theta, \phi)=f(\theta, \phi)\)</span>.</p></li>
<li><p><strong>r_1</strong> (<em>float</em><em> or </em><em>None</em>) – The radius of the exterior boundary; if set to None, <cite>g</cite> must also be None.</p></li>
<li><p><strong>g</strong> (<em>callable</em><em> or </em><em>None</em>) – The value of <span class="math notranslate nohighlight">\(u\)</span> on the exterior boundary. <span class="math notranslate nohighlight">\(u(r_1, \theta, \phi)=g(\theta, \phi)\)</span>. If set to None, <cite>r_1</cite> must also be set to None.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="neurodiffeq.conditions.DirichletBVPSpherical.enforce"><a name="//apple_ref/cpp/Method/neurodiffeq.conditions.DirichletBVPSpherical.enforce"></a>
<code class="sig-name descname">enforce</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">net</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">coordinates</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.conditions.DirichletBVPSpherical.enforce" title="Permalink to this definition">¶</a></dt>
<dd><p>Enforces this condition on a network.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>net</strong> (<cite>torch.nn.Module</cite>) – The network whose output is to be re-parameterized.</p></li>
<li><p><strong>coordinates</strong> (<cite>torch.Tensor</cite>) – Inputs of the neural network.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The re-parameterized output, where the condition is automatically satisfied.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>torch.Tensor</cite></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="neurodiffeq.conditions.DirichletBVPSpherical.parameterize"><a name="//apple_ref/cpp/Method/neurodiffeq.conditions.DirichletBVPSpherical.parameterize"></a>
<code class="sig-name descname">parameterize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">output_tensor</span></em>, <em class="sig-param"><span class="n">r</span></em>, <em class="sig-param"><span class="n">theta</span></em>, <em class="sig-param"><span class="n">phi</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.conditions.DirichletBVPSpherical.parameterize" title="Permalink to this definition">¶</a></dt>
<dd><p>Re-parameterizes outputs such that the Dirichlet condition is satisfied on both spherical boundaries.</p>
<ul>
<li><p>If both inner and outer boundaries are specified
<span class="math notranslate nohighlight">\(u(r_0,\theta,\phi)=f(\theta,\phi)\)</span> and
<span class="math notranslate nohighlight">\(u(r_1,\theta,\phi)=g(\theta,\phi)\)</span>:</p>
<p>The re-parameterization is
<span class="math notranslate nohighlight">\(\big(1-\tilde{r}\big)f(\theta,\phi)+\tilde{r}g(\theta,\phi)
+\Big(1-e^{\tilde{r}(1-{\tilde{r}})}\Big)\mathrm{ANN}(r, \theta, \phi)\)</span>
where <span class="math notranslate nohighlight">\(\displaystyle\tilde{r}=\frac{r-r_0}{r_1-r_0}\)</span>;</p>
</li>
<li><p>If only one boundary is specified (inner or outer) <span class="math notranslate nohighlight">\(u(r_0,\theta,\phi)=f(\theta,\phi)\)</span></p>
<p>The re-parameterization is
<span class="math notranslate nohighlight">\(f(\theta,\phi)+\Big(1-e^{-|r-r_0|}\Big)\mathrm{ANN}(r, \theta, \phi)\)</span>;</p>
</li>
</ul>
<p>where <span class="math notranslate nohighlight">\(\mathrm{ANN}\)</span> is the neural network.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>output_tensor</strong> (<cite>torch.Tensor</cite>) – Output of the neural network.</p></li>
<li><p><strong>r</strong> (<cite>torch.Tensor</cite>) – The radii (or <span class="math notranslate nohighlight">\(r\)</span>-component) of the inputs to the network.</p></li>
<li><p><strong>theta</strong> (<cite>torch.Tensor</cite>) – The co-latitudes (or <span class="math notranslate nohighlight">\(\theta\)</span>-component) of the inputs to the network.</p></li>
<li><p><strong>phi</strong> (<cite>torch.Tensor</cite>) – The longitudes (or <span class="math notranslate nohighlight">\(\phi\)</span>-component) of the inputs to the network.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The re-parameterized output of the network.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>torch.Tensor</cite></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="neurodiffeq.conditions.DirichletBVPSpherical.set_impose_on"><a name="//apple_ref/cpp/Method/neurodiffeq.conditions.DirichletBVPSpherical.set_impose_on"></a>
<code class="sig-name descname">set_impose_on</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ith_unit</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.conditions.DirichletBVPSpherical.set_impose_on" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>[DEPRECATED]</strong> When training several functions with a single, multi-output network, this method is called
(by a <cite>Solver</cite> class or a <cite>solve</cite> function) to keep track of which output is being parameterized.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>ith_unit</strong> (<em>int</em>) – The index of network output to be parameterized.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is deprecated and retained for backward compatibility only. Users interested in enforcing
conditions on multi-output networks should consider using a <code class="docutils literal notranslate"><span class="pre">neurodiffeq.conditions.EnsembleCondition</span></code>.</p>
</div>
</dd></dl>
</dd></dl>
<dl class="py class">
<dt id="neurodiffeq.conditions.DirichletBVPSphericalBasis"><a name="//apple_ref/cpp/Class/neurodiffeq.conditions.DirichletBVPSphericalBasis"></a>
<em class="property">class </em><code class="sig-prename descclassname">neurodiffeq.conditions.</code><code class="sig-name descname">DirichletBVPSphericalBasis</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">r_0</span></em>, <em class="sig-param"><span class="n">R_0</span></em>, <em class="sig-param"><span class="n">r_1</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">R_1</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">max_degree</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.conditions.DirichletBVPSphericalBasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#neurodiffeq.conditions.BaseCondition" title="neurodiffeq.conditions.BaseCondition"><code class="xref py py-class docutils literal notranslate"><span class="pre">neurodiffeq.conditions.BaseCondition</span></code></a></p>
<p>Similar to <code class="docutils literal notranslate"><span class="pre">neurodiffeq.conditions.DirichletBVPSpherical</span></code>.
The only difference is this condition is enforced on a neural net that only takes in <span class="math notranslate nohighlight">\(r\)</span>
and returns the spherical harmonic coefficients R(r).
We constrain the coefficients <span class="math notranslate nohighlight">\(R_k(r)\)</span> in <span class="math notranslate nohighlight">\(u(r,\theta,\phi)=\sum_{k}R_k(r)Y_k(\theta,\phi)\)</span>,
where <span class="math notranslate nohighlight">\(\big\{Y_k(\theta,\phi)\big\}_{k=1}^{K}\)</span> can be <strong>any spherical function basis</strong>.
A recommended choice is the real spherical harmonics <span class="math notranslate nohighlight">\(Y_l^m(\theta,\phi)\)</span>,
where <span class="math notranslate nohighlight">\(l\)</span> is the degree of the spherical harmonics and <span class="math notranslate nohighlight">\(m\)</span> is the order of the spherical harmonics.</p>
<p>The boundary conditions are: <span class="math notranslate nohighlight">\(\mathbf{R}(r_0)=\mathbf{R}_0\)</span> and <span class="math notranslate nohighlight">\(\mathbf{R}(r_1)=\mathbf{R}_1\)</span>,
where <span class="math notranslate nohighlight">\(\mathbf{R}\)</span> is a vector whose components are <span class="math notranslate nohighlight">\(\big\{R_k\big\}_{k=1}^{K}\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>r_0</strong> (<em>float</em>) – The radius of the interior boundary. When r_0 = 0, the interior boundary is collapsed to a single point (center of the ball)</p></li>
<li><p><strong>R_0</strong> (<cite>torch.Tensor</cite>) – The value of harmonic coefficients <span class="math notranslate nohighlight">\(\mathbf{R}\)</span> on the interior boundary. <span class="math notranslate nohighlight">\(\mathbf{R}(r_0)=\mathbf{R}_0\)</span>.</p></li>
<li><p><strong>r_1</strong> (<em>float</em><em> or </em><em>None</em>) – The radius of the exterior boundary; if set to None, <cite>R_1</cite> must also be None</p></li>
<li><p><strong>R_1</strong> (<cite>torch.Tensor</cite>) – The value of harmonic coefficients <span class="math notranslate nohighlight">\(\mathbf{R}\)</span> on the exterior boundary. <span class="math notranslate nohighlight">\(\mathbf{R}(r_1)=\mathbf{R}_1\)</span>.</p></li>
<li><p><strong>max_degree</strong> (<em>int</em>) – <strong>[DEPRECATED]</strong> highest degree when using spherical harmonics</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="neurodiffeq.conditions.DirichletBVPSphericalBasis.enforce"><a name="//apple_ref/cpp/Method/neurodiffeq.conditions.DirichletBVPSphericalBasis.enforce"></a>
<code class="sig-name descname">enforce</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">net</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">coordinates</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.conditions.DirichletBVPSphericalBasis.enforce" title="Permalink to this definition">¶</a></dt>
<dd><p>Enforces this condition on a network.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>net</strong> (<cite>torch.nn.Module</cite>) – The network whose output is to be re-parameterized.</p></li>
<li><p><strong>coordinates</strong> (<cite>torch.Tensor</cite>) – Inputs of the neural network.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The re-parameterized output, where the condition is automatically satisfied.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>torch.Tensor</cite></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="neurodiffeq.conditions.DirichletBVPSphericalBasis.parameterize"><a name="//apple_ref/cpp/Method/neurodiffeq.conditions.DirichletBVPSphericalBasis.parameterize"></a>
<code class="sig-name descname">parameterize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">output_tensor</span></em>, <em class="sig-param"><span class="n">r</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.conditions.DirichletBVPSphericalBasis.parameterize" title="Permalink to this definition">¶</a></dt>
<dd><p>Re-parameterizes outputs such that the Dirichlet condition is satisfied on both spherical boundaries.</p>
<ul>
<li><p>If both inner and outer boundaries are specified
<span class="math notranslate nohighlight">\(\mathbf{R}(r_0,\theta,\phi)=\mathbf{R}_0\)</span> and
<span class="math notranslate nohighlight">\(\mathbf{R}(r_1,\theta,\phi)=\mathbf{R}_1\)</span>.</p>
<p>The re-parameterization is
<span class="math notranslate nohighlight">\(\big(1-\tilde{r}\big)\mathbf{R}_0+\tilde{r}\mathbf{R}_1
+\Big(1-e^{\tilde{r}(1-{\tilde{r}})}\Big)\mathrm{ANN}(r)\)</span>
where <span class="math notranslate nohighlight">\(\displaystyle\tilde{r}=\frac{r-r_0}{r_1-r_0}\)</span>;</p>
</li>
<li><p>If only one boundary is specified (inner or outer) <span class="math notranslate nohighlight">\(\mathbf{R}(r_0,\theta,\phi)=\mathbf{R_0}\)</span></p>
<p>The re-parameterization is
<span class="math notranslate nohighlight">\(\mathbf{R}_0+\Big(1-e^{-|r-r_0|}\Big)\mathrm{ANN}(r)\)</span>;</p>
</li>
</ul>
<p>where <span class="math notranslate nohighlight">\(\mathrm{ANN}\)</span> is the neural network.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>output_tensor</strong> (<cite>torch.Tensor</cite>) – Output of the neural network.</p></li>
<li><p><strong>r</strong> (<cite>torch.Tensor</cite>) – The radii (or <span class="math notranslate nohighlight">\(r\)</span>-component) of the inputs to the network.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The re-parameterized output of the network.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>torch.Tensor</cite></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="neurodiffeq.conditions.DirichletBVPSphericalBasis.set_impose_on"><a name="//apple_ref/cpp/Method/neurodiffeq.conditions.DirichletBVPSphericalBasis.set_impose_on"></a>
<code class="sig-name descname">set_impose_on</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ith_unit</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.conditions.DirichletBVPSphericalBasis.set_impose_on" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>[DEPRECATED]</strong> When training several functions with a single, multi-output network, this method is called
(by a <cite>Solver</cite> class or a <cite>solve</cite> function) to keep track of which output is being parameterized.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>ith_unit</strong> (<em>int</em>) – The index of network output to be parameterized.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is deprecated and retained for backward compatibility only. Users interested in enforcing
conditions on multi-output networks should consider using a <code class="docutils literal notranslate"><span class="pre">neurodiffeq.conditions.EnsembleCondition</span></code>.</p>
</div>
</dd></dl>
</dd></dl>
<dl class="py class">
<dt id="neurodiffeq.conditions.EnsembleCondition"><a name="//apple_ref/cpp/Class/neurodiffeq.conditions.EnsembleCondition"></a>
<em class="property">class </em><code class="sig-prename descclassname">neurodiffeq.conditions.</code><code class="sig-name descname">EnsembleCondition</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">sub_conditions</span></em>, <em class="sig-param"><span class="n">force</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.conditions.EnsembleCondition" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#neurodiffeq.conditions.BaseCondition" title="neurodiffeq.conditions.BaseCondition"><code class="xref py py-class docutils literal notranslate"><span class="pre">neurodiffeq.conditions.BaseCondition</span></code></a></p>
<p>An ensemble condition that enforces sub-conditions on individual output units of the networks.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sub_conditions</strong> (<a class="reference internal" href="#neurodiffeq.conditions.BaseCondition" title="neurodiffeq.conditions.BaseCondition"><em>BaseCondition</em></a>) – Condition(s) to be ensemble’d.</p></li>
<li><p><strong>force</strong> (<em>bool</em>) – Whether or not to force ensembl’ing even when <cite>.enforce</cite> is overridden in one of the sub-conditions.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="neurodiffeq.conditions.EnsembleCondition.enforce"><a name="//apple_ref/cpp/Method/neurodiffeq.conditions.EnsembleCondition.enforce"></a>
<code class="sig-name descname">enforce</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">net</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">coordinates</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.conditions.EnsembleCondition.enforce" title="Permalink to this definition">¶</a></dt>
<dd><p>Enforces this condition on a network.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>net</strong> (<cite>torch.nn.Module</cite>) – The network whose output is to be re-parameterized.</p></li>
<li><p><strong>coordinates</strong> (<cite>torch.Tensor</cite>) – Inputs of the neural network.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The re-parameterized output, where the condition is automatically satisfied.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>torch.Tensor</cite></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="neurodiffeq.conditions.EnsembleCondition.parameterize"><a name="//apple_ref/cpp/Method/neurodiffeq.conditions.EnsembleCondition.parameterize"></a>
<code class="sig-name descname">parameterize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">output_tensor</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">input_tensors</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.conditions.EnsembleCondition.parameterize" title="Permalink to this definition">¶</a></dt>
<dd><p>Re-parameterizes each column in output_tensor individually, using its corresponding sub-condition.
This is useful when solving differential equations with a single, multi-output network.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>output_tensor</strong> (<cite>torch.Tensor</cite>) – Output of the neural network. Number of units (.shape[1]) must equal number of sub-conditions.</p></li>
<li><p><strong>input_tensors</strong> (<cite>torch.Tensor</cite>) – Inputs to the neural network; i.e., sampled coordinates; i.e., independent variables.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The column-wise re-parameterized network output, concatenated across columns so that it’s still one tensor.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>torch.Tensor</cite></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="neurodiffeq.conditions.EnsembleCondition.set_impose_on"><a name="//apple_ref/cpp/Method/neurodiffeq.conditions.EnsembleCondition.set_impose_on"></a>
<code class="sig-name descname">set_impose_on</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ith_unit</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.conditions.EnsembleCondition.set_impose_on" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>[DEPRECATED]</strong> When training several functions with a single, multi-output network, this method is called
(by a <cite>Solver</cite> class or a <cite>solve</cite> function) to keep track of which output is being parameterized.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>ith_unit</strong> (<em>int</em>) – The index of network output to be parameterized.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is deprecated and retained for backward compatibility only. Users interested in enforcing
conditions on multi-output networks should consider using a <code class="docutils literal notranslate"><span class="pre">neurodiffeq.conditions.EnsembleCondition</span></code>.</p>
</div>
</dd></dl>
</dd></dl>
<dl class="py class">
<dt id="neurodiffeq.conditions.IBVP1D"><a name="//apple_ref/cpp/Class/neurodiffeq.conditions.IBVP1D"></a>
<em class="property">class </em><code class="sig-prename descclassname">neurodiffeq.conditions.</code><code class="sig-name descname">IBVP1D</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x_min</span></em>, <em class="sig-param"><span class="n">x_max</span></em>, <em class="sig-param"><span class="n">t_min</span></em>, <em class="sig-param"><span class="n">t_min_val</span></em>, <em class="sig-param"><span class="n">x_min_val</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">x_min_prime</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">x_max_val</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">x_max_prime</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.conditions.IBVP1D" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#neurodiffeq.conditions.BaseCondition" title="neurodiffeq.conditions.BaseCondition"><code class="xref py py-class docutils literal notranslate"><span class="pre">neurodiffeq.conditions.BaseCondition</span></code></a></p>
<p>An initial &amp; boundary condition on a 1-D range where <span class="math notranslate nohighlight">\(x\in[x_0, x_1]\)</span> and time starts at <span class="math notranslate nohighlight">\(t_0\)</span>.
The conditions should have the following parts:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(u(x,t_0)=u_0(x)\)</span>,</p></li>
<li><p><span class="math notranslate nohighlight">\(u(x_0,t)=g(t)\)</span> or <span class="math notranslate nohighlight">\(u'_x(x_0,t)=p(t)\)</span>,</p></li>
<li><p><span class="math notranslate nohighlight">\(u(x_1,t)=h(t)\)</span> or <span class="math notranslate nohighlight">\(u'_x(x_1,t)=q(t)\)</span>,</p></li>
</ul>
<p>where <span class="math notranslate nohighlight">\(\displaystyle u'_x=\frac{\partial u}{\partial x}\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x_min</strong> (<em>float</em>) – The lower bound of x, the <span class="math notranslate nohighlight">\(x_0\)</span>.</p></li>
<li><p><strong>x_max</strong> (<em>float</em>) – The upper bound of x, the <span class="math notranslate nohighlight">\(x_1\)</span>.</p></li>
<li><p><strong>t_min</strong> (<em>float</em>) – The initial time, the <span class="math notranslate nohighlight">\(t_0\)</span>.</p></li>
<li><p><strong>t_min_val</strong> (<em>callable</em>) – The initial condition, the <span class="math notranslate nohighlight">\(u_0(x)\)</span>.</p></li>
<li><p><strong>x_min_val</strong> (<em>callable</em><em>, </em><em>optional</em>) – The Dirichlet boundary condition when <span class="math notranslate nohighlight">\(x = x_0\)</span>, the <span class="math notranslate nohighlight">\(u(x_0, t)\)</span>, defaults to None.</p></li>
<li><p><strong>x_min_prime</strong> (<em>callable</em><em>, </em><em>optional</em>) – The Neumann boundary condition when <span class="math notranslate nohighlight">\(x = x_0\)</span>, the <span class="math notranslate nohighlight">\(u'_x(x_0, t)\)</span>, defaults to None.</p></li>
<li><p><strong>x_max_val</strong> (<em>callable</em><em>, </em><em>optional</em>) – The Dirichlet boundary condition when <span class="math notranslate nohighlight">\(x = x_1\)</span>, the <span class="math notranslate nohighlight">\(u(x_1, t)\)</span>, defaults to None.</p></li>
<li><p><strong>x_max_prime</strong> (<em>callable</em><em>, </em><em>optional</em>) – The Neumann boundary condition when <span class="math notranslate nohighlight">\(x = x_1\)</span>, the <span class="math notranslate nohighlight">\(u'_x(x_1, t)\)</span>, defaults to None.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>NotImplementedError</strong> – When unimplemented boundary conditions are configured.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This condition cannot be passed to <code class="docutils literal notranslate"><span class="pre">neurodiffeq.conditions.EnsembleCondition</span></code> unless both boundaries uses
Dirichlet conditions (by specifying only <code class="docutils literal notranslate"><span class="pre">x_min_val</span></code> and <code class="docutils literal notranslate"><span class="pre">x_max_val</span></code>) and <code class="docutils literal notranslate"><span class="pre">force</span></code> is set to True in
EnsembleCondition’s constructor.</p>
</div>
<dl class="py method">
<dt id="neurodiffeq.conditions.IBVP1D.enforce"><a name="//apple_ref/cpp/Method/neurodiffeq.conditions.IBVP1D.enforce"></a>
<code class="sig-name descname">enforce</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">net</span></em>, <em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">t</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.conditions.IBVP1D.enforce" title="Permalink to this definition">¶</a></dt>
<dd><p>Enforces this condition on a network with inputs <cite>x</cite> and <cite>t</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>net</strong> (<cite>torch.nn.Module</cite>) – The network whose output is to be re-parameterized.</p></li>
<li><p><strong>x</strong> (<cite>torch.Tensor</cite>) – The <span class="math notranslate nohighlight">\(x\)</span>-coordinates of the samples; i.e., the spatial coordinates.</p></li>
<li><p><strong>t</strong> (<cite>torch.Tensor</cite>) – The <span class="math notranslate nohighlight">\(t\)</span>-coordinates of the samples; i.e., the temporal coordinates.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The re-parameterized output, where the condition is automatically satisfied.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>torch.Tensor</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method overrides the default method of <code class="docutils literal notranslate"><span class="pre">neurodiffeq.conditions.BaseCondition</span></code> .
In general, you should avoid overriding <code class="docutils literal notranslate"><span class="pre">enforce</span></code> when implementing custom boundary conditions.</p>
</div>
</dd></dl>
<dl class="py method">
<dt id="neurodiffeq.conditions.IBVP1D.parameterize"><a name="//apple_ref/cpp/Method/neurodiffeq.conditions.IBVP1D.parameterize"></a>
<code class="sig-name descname">parameterize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">u</span></em>, <em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">t</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">additional_tensors</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.conditions.IBVP1D.parameterize" title="Permalink to this definition">¶</a></dt>
<dd><p>Re-parameterizes outputs such that the initial and boundary conditions are satisfied.</p>
<p>The Initial condition is always <span class="math notranslate nohighlight">\(u(x,t_0)=u_0(x)\)</span>. There are four boundary conditions that are
currently implemented:</p>
<ul>
<li><p>For Dirichlet-Dirichlet boundary condition <span class="math notranslate nohighlight">\(u(x_0,t)=g(t)\)</span> and <span class="math notranslate nohighlight">\(u(x_1,t)=h(t)\)</span>:</p>
<p>The re-parameterization is
<span class="math notranslate nohighlight">\(\displaystyle u(x,t)=A(x,t)+\tilde{x}\big(1-\tilde{x}\big)\Big(1-e^{-\tilde{t}}\Big)\mathrm{ANN}(x,t)\)</span>,
where <span class="math notranslate nohighlight">\(\displaystyle A(x,t)=u_0(x)+
\tilde{x}\big(h(t)-h(t_0)\big)+\big(1-\tilde{x}\big)\big(g(t)-g(t_0)\big)\)</span>.</p>
</li>
<li><p>For Dirichlet-Neumann boundary condition <span class="math notranslate nohighlight">\(u(x_0,t)=g(t)\)</span> and <span class="math notranslate nohighlight">\(u'_x(x_1, t)=q(t)\)</span>:</p>
<p>The re-parameterization is
<span class="math notranslate nohighlight">\(\displaystyle u(x,t)=A(x,t)+\tilde{x}\Big(1-e^{-\tilde{t}}\Big)
\Big(\mathrm{ANN}(x,t)-\big(x_1-x_0\big)\mathrm{ANN}'_x(x_1,t)-\mathrm{ANN}(x_1,t)\Big)\)</span>,
where <span class="math notranslate nohighlight">\(\displaystyle A(x,t)=u_0(x)+\big(x-x_0\big)\big(q(t)-q(t_0)\big)+\big(g(t)-g(t_0)\big)\)</span>.</p>
</li>
<li><p>For Neumann-Dirichlet boundary condition <span class="math notranslate nohighlight">\(u'_x(x_0,t)=p(t)\)</span> and <span class="math notranslate nohighlight">\(u(x_1, t)=h(t)\)</span>:</p>
<p>The re-parameterization is
<span class="math notranslate nohighlight">\(\displaystyle u(x,t)=A(x,t)+\big(1-\tilde{x}\big)\Big(1-e^{-\tilde{t}}\Big)
\Big(\mathrm{ANN}(x,t)-\big(x_1-x_0\big)\mathrm{ANN}'_x(x_0,t)-\mathrm{ANN}(x_0,t)\Big)\)</span>,
where <span class="math notranslate nohighlight">\(\displaystyle A(x,t)=u_0(x)+\big(x_1-x\big)\big(p(t)-p(t_0)\big)+\big(h(t)-h(t_0)\big)\)</span>.</p>
</li>
<li><p>For Neumann-Neumann boundary condition <span class="math notranslate nohighlight">\(u'_x(x_0,t)=p(t)\)</span> and <span class="math notranslate nohighlight">\(u'_x(x_1, t)=q(t)\)</span></p>
<p>The re-parameterization is
<span class="math notranslate nohighlight">\(\displaystyle u(x,t)=A(x,t)+\left(1-e^{-\tilde{t}}\right)
\Big(
\mathrm{ANN}(x,t)-\big(x-x_0\big)\mathrm{ANN}'_x(x_0,t)
+\frac{1}{2}\tilde{x}^2\big(x_1-x_0\big)
\big(\mathrm{ANN}'_x(x_0,t)-\mathrm{ANN}'_x(x_1,t)\big)
\Big)\)</span>,
where <span class="math notranslate nohighlight">\(\displaystyle A(x,t)=u_0(x)
-\frac{1}{2}\big(1-\tilde{x}\big)^2\big(x_1-x_0\big)\big(p(t)-p(t_0)\big)
+\frac{1}{2}\tilde{x}^2\big(x_1-x_0\big)\big(q(t)-q(t_0)\big)\)</span>.</p>
</li>
</ul>
<p>Notations:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\displaystyle\tilde{t}=\frac{t-t_0}{t_1-t_0}\)</span>,</p></li>
<li><p><span class="math notranslate nohighlight">\(\displaystyle\tilde{x}=\frac{x-x_0}{x_1-x_0}\)</span>,</p></li>
<li><p><span class="math notranslate nohighlight">\(\displaystyle\mathrm{ANN}\)</span> is the neural network,</p></li>
<li><p>and <span class="math notranslate nohighlight">\(\displaystyle\mathrm{ANN}'_x=\frac{\partial ANN}{\partial x}\)</span>.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>output_tensor</strong> (<cite>torch.Tensor</cite>) – Output of the neural network.</p></li>
<li><p><strong>x</strong> (<cite>torch.Tensor</cite>) – The <span class="math notranslate nohighlight">\(x\)</span>-coordinates of the samples; i.e., the spatial coordinates.</p></li>
<li><p><strong>t</strong> (<cite>torch.Tensor</cite>) – The <span class="math notranslate nohighlight">\(t\)</span>-coordinates of the samples; i.e., the temporal coordinates.</p></li>
<li><p><strong>additional_tensors</strong> (<cite>torch.Tensor</cite>) – additional tensors that will be passed by <code class="docutils literal notranslate"><span class="pre">enforce</span></code></p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The re-parameterized output of the network.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>torch.Tensor</cite></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="neurodiffeq.conditions.IBVP1D.set_impose_on"><a name="//apple_ref/cpp/Method/neurodiffeq.conditions.IBVP1D.set_impose_on"></a>
<code class="sig-name descname">set_impose_on</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ith_unit</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.conditions.IBVP1D.set_impose_on" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>[DEPRECATED]</strong> When training several functions with a single, multi-output network, this method is called
(by a <cite>Solver</cite> class or a <cite>solve</cite> function) to keep track of which output is being parameterized.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>ith_unit</strong> (<em>int</em>) – The index of network output to be parameterized.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is deprecated and retained for backward compatibility only. Users interested in enforcing
conditions on multi-output networks should consider using a <code class="docutils literal notranslate"><span class="pre">neurodiffeq.conditions.EnsembleCondition</span></code>.</p>
</div>
</dd></dl>
</dd></dl>
<dl class="py class">
<dt id="neurodiffeq.conditions.IVP"><a name="//apple_ref/cpp/Class/neurodiffeq.conditions.IVP"></a>
<em class="property">class </em><code class="sig-prename descclassname">neurodiffeq.conditions.</code><code class="sig-name descname">IVP</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">t_0</span></em>, <em class="sig-param"><span class="n">x_0</span></em>, <em class="sig-param"><span class="n">x_0_prime</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.conditions.IVP" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#neurodiffeq.conditions.BaseCondition" title="neurodiffeq.conditions.BaseCondition"><code class="xref py py-class docutils literal notranslate"><span class="pre">neurodiffeq.conditions.BaseCondition</span></code></a></p>
<p>An initial value problem of one of the following forms:</p>
<ul class="simple">
<li><p>Dirichlet condition: <span class="math notranslate nohighlight">\(x(t_0)=x_0\)</span>.</p></li>
<li><p>Neumann condition: <span class="math notranslate nohighlight">\(\displaystyle\frac{\partial x}{\partial t}\bigg|_{t = t_0} = x_0'\)</span>.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>t_0</strong> (<em>float</em>) – The initial time.</p></li>
<li><p><strong>x_0</strong> (<em>float</em>) – The initial value of <span class="math notranslate nohighlight">\(x\)</span>. <span class="math notranslate nohighlight">\(x(t_0)=x_0\)</span>.</p></li>
<li><p><strong>x_0_prime</strong> (<em>float</em><em>, </em><em>optional</em>) – The initial derivative of <span class="math notranslate nohighlight">\(x\)</span> w.r.t. <span class="math notranslate nohighlight">\(t\)</span>. <span class="math notranslate nohighlight">\(\displaystyle\frac{\partial x}{\partial t}\bigg|_{t = t_0} = x_0'\)</span>, defaults to None.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="neurodiffeq.conditions.IVP.enforce"><a name="//apple_ref/cpp/Method/neurodiffeq.conditions.IVP.enforce"></a>
<code class="sig-name descname">enforce</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">net</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">coordinates</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.conditions.IVP.enforce" title="Permalink to this definition">¶</a></dt>
<dd><p>Enforces this condition on a network.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>net</strong> (<cite>torch.nn.Module</cite>) – The network whose output is to be re-parameterized.</p></li>
<li><p><strong>coordinates</strong> (<cite>torch.Tensor</cite>) – Inputs of the neural network.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The re-parameterized output, where the condition is automatically satisfied.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>torch.Tensor</cite></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="neurodiffeq.conditions.IVP.parameterize"><a name="//apple_ref/cpp/Method/neurodiffeq.conditions.IVP.parameterize"></a>
<code class="sig-name descname">parameterize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">output_tensor</span></em>, <em class="sig-param"><span class="n">t</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.conditions.IVP.parameterize" title="Permalink to this definition">¶</a></dt>
<dd><p>Re-parameterizes outputs such that the Dirichlet/Neumann condition is satisfied.</p>
<ul class="simple">
<li><p>For Dirichlet condition, the re-parameterization is
<span class="math notranslate nohighlight">\(\displaystyle x(t) = x_0 + \left(1 - e^{-(t-t_0)}\right) \mathrm{ANN}(t)\)</span>
where <span class="math notranslate nohighlight">\(\mathrm{ANN}\)</span> is the neural network.</p></li>
<li><p>For Neumann condition, the re-parameterization is
<span class="math notranslate nohighlight">\(\displaystyle x(t) = x_0 + (t-t_0) x'_0 + \left(1 - e^{-(t-t_0)}\right)^2 \mathrm{ANN}(t)\)</span>
where <span class="math notranslate nohighlight">\(\mathrm{ANN}\)</span> is the neural network.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>output_tensor</strong> (<cite>torch.Tensor</cite>) – Output of the neural network.</p></li>
<li><p><strong>t</strong> (<cite>torch.Tensor</cite>) – Input to the neural network; i.e., sampled time-points; i.e., independent variables.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The re-parameterized output of the network.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>torch.Tensor</cite></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="neurodiffeq.conditions.IVP.set_impose_on"><a name="//apple_ref/cpp/Method/neurodiffeq.conditions.IVP.set_impose_on"></a>
<code class="sig-name descname">set_impose_on</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ith_unit</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.conditions.IVP.set_impose_on" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>[DEPRECATED]</strong> When training several functions with a single, multi-output network, this method is called
(by a <cite>Solver</cite> class or a <cite>solve</cite> function) to keep track of which output is being parameterized.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>ith_unit</strong> (<em>int</em>) – The index of network output to be parameterized.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is deprecated and retained for backward compatibility only. Users interested in enforcing
conditions on multi-output networks should consider using a <code class="docutils literal notranslate"><span class="pre">neurodiffeq.conditions.EnsembleCondition</span></code>.</p>
</div>
</dd></dl>
</dd></dl>
<dl class="py class">
<dt id="neurodiffeq.conditions.InfDirichletBVPSpherical"><a name="//apple_ref/cpp/Class/neurodiffeq.conditions.InfDirichletBVPSpherical"></a>
<em class="property">class </em><code class="sig-prename descclassname">neurodiffeq.conditions.</code><code class="sig-name descname">InfDirichletBVPSpherical</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">r_0</span></em>, <em class="sig-param"><span class="n">f</span></em>, <em class="sig-param"><span class="n">g</span></em>, <em class="sig-param"><span class="n">order</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.conditions.InfDirichletBVPSpherical" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#neurodiffeq.conditions.BaseCondition" title="neurodiffeq.conditions.BaseCondition"><code class="xref py py-class docutils literal notranslate"><span class="pre">neurodiffeq.conditions.BaseCondition</span></code></a></p>
<p>Similar to <code class="docutils literal notranslate"><span class="pre">neurodiffeq.conditions.DirichletBVPSpherical</span></code>. but with <span class="math notranslate nohighlight">\(r_1\to+\infty\)</span>. Specifically,</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\displaystyle u(r_0,\theta,\phi)=f(\theta,\phi)\)</span>,</p></li>
<li><p><span class="math notranslate nohighlight">\(\lim_{r\to+\infty}u(r,\theta,\phi)=g(\theta,\phi)\)</span>.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>r_0</strong> (<em>float</em>) – The radius of the interior boundary. When <span class="math notranslate nohighlight">\(r_0=0\)</span>, the interior boundary collapses to a single point (center of the ball).</p></li>
<li><p><strong>f</strong> (<em>callable</em>) – The value of <span class="math notranslate nohighlight">\(u\)</span> on the interior boundary. <span class="math notranslate nohighlight">\(u(r_0,\theta,\phi)=f(\theta,\phi)\)</span>.</p></li>
<li><p><strong>g</strong> (<em>callable</em>) – The value of <span class="math notranslate nohighlight">\(u\)</span> at infinity. <span class="math notranslate nohighlight">\(\lim_{r\to+\infty}u(r,\theta,\phi)=g(\theta,\phi)\)</span>.</p></li>
<li><p><strong>order</strong> (<em>int</em><em> or </em><em>float</em><em>, </em><em>optional</em>) – The smallest <span class="math notranslate nohighlight">\(k\)</span> such that <span class="math notranslate nohighlight">\(\lim_{r\to+\infty}u(r,\theta,\phi)e^{-kr}=0\)</span>, defaults to 1.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="neurodiffeq.conditions.InfDirichletBVPSpherical.enforce"><a name="//apple_ref/cpp/Method/neurodiffeq.conditions.InfDirichletBVPSpherical.enforce"></a>
<code class="sig-name descname">enforce</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">net</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">coordinates</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.conditions.InfDirichletBVPSpherical.enforce" title="Permalink to this definition">¶</a></dt>
<dd><p>Enforces this condition on a network.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>net</strong> (<cite>torch.nn.Module</cite>) – The network whose output is to be re-parameterized.</p></li>
<li><p><strong>coordinates</strong> (<cite>torch.Tensor</cite>) – Inputs of the neural network.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The re-parameterized output, where the condition is automatically satisfied.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>torch.Tensor</cite></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="neurodiffeq.conditions.InfDirichletBVPSpherical.parameterize"><a name="//apple_ref/cpp/Method/neurodiffeq.conditions.InfDirichletBVPSpherical.parameterize"></a>
<code class="sig-name descname">parameterize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">output_tensor</span></em>, <em class="sig-param"><span class="n">r</span></em>, <em class="sig-param"><span class="n">theta</span></em>, <em class="sig-param"><span class="n">phi</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.conditions.InfDirichletBVPSpherical.parameterize" title="Permalink to this definition">¶</a></dt>
<dd><p>Re-parameterizes outputs such that the Dirichlet condition is satisfied both at <span class="math notranslate nohighlight">\(r_0\)</span> and infinity.
The re-parameterization is</p>
<p><span class="math notranslate nohighlight">\(\begin{align}
u(r,\theta,\phi)=
&amp;e^{-k(r-r_0)}f(\theta,\phi)\\
&amp;+\tanh{\big(r-r_0\big)}g(\theta,\phi)\\
&amp;+e^{-k(r-r_0)}\tanh{\big(r-r_0\big)}\mathrm{ANN}(r,\theta,\phi)
\end{align}\)</span>,</p>
<p>where <span class="math notranslate nohighlight">\(\mathrm{ANN}\)</span> is the neural network.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>output_tensor</strong> (<cite>torch.Tensor</cite>) – Output of the neural network.</p></li>
<li><p><strong>r</strong> (<cite>torch.Tensor</cite>) – The radii (or <span class="math notranslate nohighlight">\(r\)</span>-component) of the inputs to the network.</p></li>
<li><p><strong>theta</strong> (<cite>torch.Tensor</cite>) – The co-latitudes (or <span class="math notranslate nohighlight">\(\theta\)</span>-component) of the inputs to the network.</p></li>
<li><p><strong>phi</strong> (<cite>torch.Tensor</cite>) – The longitudes (or <span class="math notranslate nohighlight">\(\phi\)</span>-component) of the inputs to the network.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The re-parameterized output of the network.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>torch.Tensor</cite></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="neurodiffeq.conditions.InfDirichletBVPSpherical.set_impose_on"><a name="//apple_ref/cpp/Method/neurodiffeq.conditions.InfDirichletBVPSpherical.set_impose_on"></a>
<code class="sig-name descname">set_impose_on</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ith_unit</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.conditions.InfDirichletBVPSpherical.set_impose_on" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>[DEPRECATED]</strong> When training several functions with a single, multi-output network, this method is called
(by a <cite>Solver</cite> class or a <cite>solve</cite> function) to keep track of which output is being parameterized.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>ith_unit</strong> (<em>int</em>) – The index of network output to be parameterized.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is deprecated and retained for backward compatibility only. Users interested in enforcing
conditions on multi-output networks should consider using a <code class="docutils literal notranslate"><span class="pre">neurodiffeq.conditions.EnsembleCondition</span></code>.</p>
</div>
</dd></dl>
</dd></dl>
<dl class="py class">
<dt id="neurodiffeq.conditions.InfDirichletBVPSphericalBasis"><a name="//apple_ref/cpp/Class/neurodiffeq.conditions.InfDirichletBVPSphericalBasis"></a>
<em class="property">class </em><code class="sig-prename descclassname">neurodiffeq.conditions.</code><code class="sig-name descname">InfDirichletBVPSphericalBasis</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">r_0</span></em>, <em class="sig-param"><span class="n">R_0</span></em>, <em class="sig-param"><span class="n">R_inf</span></em>, <em class="sig-param"><span class="n">order</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">max_degree</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.conditions.InfDirichletBVPSphericalBasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#neurodiffeq.conditions.BaseCondition" title="neurodiffeq.conditions.BaseCondition"><code class="xref py py-class docutils literal notranslate"><span class="pre">neurodiffeq.conditions.BaseCondition</span></code></a></p>
<p>Similar to <code class="docutils literal notranslate"><span class="pre">neurodiffeq.conditions.InfDirichletBVPSpherical</span></code>.
The only difference is this condition is enforced on a neural net that only takes in <span class="math notranslate nohighlight">\(r\)</span>
and returns the spherical harmonic coefficients R(r).
We constrain the coefficients <span class="math notranslate nohighlight">\(R_k(r)\)</span> in <span class="math notranslate nohighlight">\(u(r,\theta,\phi)=\sum_{k}R_k(r)Y_k(\theta,\phi)\)</span>,
where <span class="math notranslate nohighlight">\(\big\{Y_k(\theta,\phi)\big\}_{k=1}^{K}\)</span> can be <strong>any spherical function basis</strong>.
A recommended choice is the real spherical harmonics <span class="math notranslate nohighlight">\(Y_l^m(\theta,\phi)\)</span>,
where <span class="math notranslate nohighlight">\(l\)</span> is the degree of the spherical harmonics and <span class="math notranslate nohighlight">\(m\)</span> is the order of the spherical harmonics.</p>
<p>The boundary conditions are:
<span class="math notranslate nohighlight">\(\mathbf{R}(r_0)=\mathbf{R}_0\)</span> and
<span class="math notranslate nohighlight">\(\lim_{r_0\to+\infty}\mathbf{R}(r)=\mathbf{R}_1\)</span>,
where <span class="math notranslate nohighlight">\(\mathbf{R}\)</span> is a vector whose components are <span class="math notranslate nohighlight">\(\big\{R_k\big\}_{k=1}^{K}\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>r_0</strong> (<em>float</em>) – The radius of the interior boundary. When r_0 = 0, the interior boundary is collapsed to a single point (center of the ball)</p></li>
<li><p><strong>R_0</strong> (<cite>torch.Tensor</cite>) – The value of harmonic coefficients <span class="math notranslate nohighlight">\(R\)</span> on the interior boundary. <span class="math notranslate nohighlight">\(R(r_0)=R_0\)</span>.</p></li>
<li><p><strong>R_inf</strong> (<cite>torch.Tensor</cite>) – The value of harmonic coefficients <span class="math notranslate nohighlight">\(R\)</span> at infinity. <span class="math notranslate nohighlight">\(\lim_{r\to+\infty}R(r)=R_\infty\)</span>.</p></li>
<li><p><strong>order</strong> (<em>int</em><em> or </em><em>float</em><em>, </em><em>optional</em>) – The smallest <span class="math notranslate nohighlight">\(k\)</span> that guarantees <span class="math notranslate nohighlight">\(\lim_{r \to +\infty} R(r) e^{-k r} = \bf 0\)</span>, defaults to 1</p></li>
<li><p><strong>max_degree</strong> (<em>int</em>) – <strong>[DEPRECATED]</strong> highest degree when using spherical harmonics</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="neurodiffeq.conditions.InfDirichletBVPSphericalBasis.enforce"><a name="//apple_ref/cpp/Method/neurodiffeq.conditions.InfDirichletBVPSphericalBasis.enforce"></a>
<code class="sig-name descname">enforce</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">net</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">coordinates</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.conditions.InfDirichletBVPSphericalBasis.enforce" title="Permalink to this definition">¶</a></dt>
<dd><p>Enforces this condition on a network.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>net</strong> (<cite>torch.nn.Module</cite>) – The network whose output is to be re-parameterized.</p></li>
<li><p><strong>coordinates</strong> (<cite>torch.Tensor</cite>) – Inputs of the neural network.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The re-parameterized output, where the condition is automatically satisfied.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>torch.Tensor</cite></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="neurodiffeq.conditions.InfDirichletBVPSphericalBasis.parameterize"><a name="//apple_ref/cpp/Method/neurodiffeq.conditions.InfDirichletBVPSphericalBasis.parameterize"></a>
<code class="sig-name descname">parameterize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">output_tensor</span></em>, <em class="sig-param"><span class="n">r</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.conditions.InfDirichletBVPSphericalBasis.parameterize" title="Permalink to this definition">¶</a></dt>
<dd><p>Re-parameterizes outputs such that the Dirichlet condition is satisfied at both <span class="math notranslate nohighlight">\(r_0\)</span> and infinity.</p>
<p>The re-parameterization is</p>
<p><span class="math notranslate nohighlight">\(\begin{align}
u(r,\theta,\phi)=
&amp;e^{-k(r-r_0)}\mathbf{R}_0\\
&amp;+\tanh{\big(r-r_0\big)}\mathbf{R}_1\\
&amp;+e^{-k(r-r_0)}\tanh{\big(r-r_0\big)}\mathrm{ANN}(r)
\end{align}\)</span>,</p>
<p>where <span class="math notranslate nohighlight">\(\mathrm{ANN}\)</span> is the neural network.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>output_tensor</strong> (<cite>torch.Tensor</cite>) – Output of the neural network.</p></li>
<li><p><strong>r</strong> (<cite>torch.Tensor</cite>) – The radii (or <span class="math notranslate nohighlight">\(r\)</span>-component) of the inputs to the network.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The re-parameterized output of the network.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>torch.Tensor</cite></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="neurodiffeq.conditions.InfDirichletBVPSphericalBasis.set_impose_on"><a name="//apple_ref/cpp/Method/neurodiffeq.conditions.InfDirichletBVPSphericalBasis.set_impose_on"></a>
<code class="sig-name descname">set_impose_on</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ith_unit</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.conditions.InfDirichletBVPSphericalBasis.set_impose_on" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>[DEPRECATED]</strong> When training several functions with a single, multi-output network, this method is called
(by a <cite>Solver</cite> class or a <cite>solve</cite> function) to keep track of which output is being parameterized.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>ith_unit</strong> (<em>int</em>) – The index of network output to be parameterized.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is deprecated and retained for backward compatibility only. Users interested in enforcing
conditions on multi-output networks should consider using a <code class="docutils literal notranslate"><span class="pre">neurodiffeq.conditions.EnsembleCondition</span></code>.</p>
</div>
</dd></dl>
</dd></dl>
<dl class="py class">
<dt id="neurodiffeq.conditions.IrregularBoundaryCondition"><a name="//apple_ref/cpp/Class/neurodiffeq.conditions.IrregularBoundaryCondition"></a>
<em class="property">class </em><code class="sig-prename descclassname">neurodiffeq.conditions.</code><code class="sig-name descname">IrregularBoundaryCondition</code><a class="headerlink" href="#neurodiffeq.conditions.IrregularBoundaryCondition" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#neurodiffeq.conditions.BaseCondition" title="neurodiffeq.conditions.BaseCondition"><code class="xref py py-class docutils literal notranslate"><span class="pre">neurodiffeq.conditions.BaseCondition</span></code></a></p>
<dl class="py method">
<dt id="neurodiffeq.conditions.IrregularBoundaryCondition.enforce"><a name="//apple_ref/cpp/Method/neurodiffeq.conditions.IrregularBoundaryCondition.enforce"></a>
<code class="sig-name descname">enforce</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">net</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">coordinates</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.conditions.IrregularBoundaryCondition.enforce" title="Permalink to this definition">¶</a></dt>
<dd><p>Enforces this condition on a network.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>net</strong> (<cite>torch.nn.Module</cite>) – The network whose output is to be re-parameterized.</p></li>
<li><p><strong>coordinates</strong> (<cite>torch.Tensor</cite>) – Inputs of the neural network.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The re-parameterized output, where the condition is automatically satisfied.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>torch.Tensor</cite></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="neurodiffeq.conditions.IrregularBoundaryCondition.in_domain"><a name="//apple_ref/cpp/Method/neurodiffeq.conditions.IrregularBoundaryCondition.in_domain"></a>
<code class="sig-name descname">in_domain</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">coordinates</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.conditions.IrregularBoundaryCondition.in_domain" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the coordinates (numpy.ndarray), the methods returns an boolean array indicating
whether the points lie within the domain.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>coordinates</strong> (<cite>numpy.ndarray</cite>) – Input tensors, each with shape (n_samples, 1).</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Whether each point lies within the domain.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>numpy.ndarray</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>This method is meant to be used by monitors for irregular domain visualization.</p></li>
</ul>
</div>
</dd></dl>
<dl class="py method">
<dt id="neurodiffeq.conditions.IrregularBoundaryCondition.parameterize"><a name="//apple_ref/cpp/Method/neurodiffeq.conditions.IrregularBoundaryCondition.parameterize"></a>
<code class="sig-name descname">parameterize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">output_tensor</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">input_tensors</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.conditions.IrregularBoundaryCondition.parameterize" title="Permalink to this definition">¶</a></dt>
<dd><p>Re-parameterizes output(s) of a network.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>output_tensor</strong> (<cite>torch.Tensor</cite>) – Output of the neural network.</p></li>
<li><p><strong>input_tensors</strong> (<cite>torch.Tensor</cite>) – Inputs to the neural network; i.e., sampled coordinates; i.e., independent variables.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The re-parameterized output of the network.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>torch.Tensor</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is <strong>abstract</strong> for BaseCondition</p>
</div>
</dd></dl>
<dl class="py method">
<dt id="neurodiffeq.conditions.IrregularBoundaryCondition.set_impose_on"><a name="//apple_ref/cpp/Method/neurodiffeq.conditions.IrregularBoundaryCondition.set_impose_on"></a>
<code class="sig-name descname">set_impose_on</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ith_unit</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.conditions.IrregularBoundaryCondition.set_impose_on" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>[DEPRECATED]</strong> When training several functions with a single, multi-output network, this method is called
(by a <cite>Solver</cite> class or a <cite>solve</cite> function) to keep track of which output is being parameterized.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>ith_unit</strong> (<em>int</em>) – The index of network output to be parameterized.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is deprecated and retained for backward compatibility only. Users interested in enforcing
conditions on multi-output networks should consider using a <code class="docutils literal notranslate"><span class="pre">neurodiffeq.conditions.EnsembleCondition</span></code>.</p>
</div>
</dd></dl>
</dd></dl>
<dl class="py class">
<dt id="neurodiffeq.conditions.NoCondition"><a name="//apple_ref/cpp/Class/neurodiffeq.conditions.NoCondition"></a>
<em class="property">class </em><code class="sig-prename descclassname">neurodiffeq.conditions.</code><code class="sig-name descname">NoCondition</code><a class="headerlink" href="#neurodiffeq.conditions.NoCondition" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#neurodiffeq.conditions.BaseCondition" title="neurodiffeq.conditions.BaseCondition"><code class="xref py py-class docutils literal notranslate"><span class="pre">neurodiffeq.conditions.BaseCondition</span></code></a></p>
<p>A polymorphic condition where no re-parameterization will be performed.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This condition is called <em>polymorphic</em> because it can be enforced on networks of arbitrary input/output sizes.</p>
</div>
<dl class="py method">
<dt id="neurodiffeq.conditions.NoCondition.enforce"><a name="//apple_ref/cpp/Method/neurodiffeq.conditions.NoCondition.enforce"></a>
<code class="sig-name descname">enforce</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">net</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">coordinates</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.conditions.NoCondition.enforce" title="Permalink to this definition">¶</a></dt>
<dd><p>Enforces this condition on a network.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>net</strong> (<cite>torch.nn.Module</cite>) – The network whose output is to be re-parameterized.</p></li>
<li><p><strong>coordinates</strong> (<cite>torch.Tensor</cite>) – Inputs of the neural network.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The re-parameterized output, where the condition is automatically satisfied.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>torch.Tensor</cite></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="neurodiffeq.conditions.NoCondition.parameterize"><a name="//apple_ref/cpp/Method/neurodiffeq.conditions.NoCondition.parameterize"></a>
<code class="sig-name descname">parameterize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">output_tensor</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">input_tensors</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.conditions.NoCondition.parameterize" title="Permalink to this definition">¶</a></dt>
<dd><p>Re-parameterizes output(s) of a network.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>output_tensor</strong> (<cite>torch.Tensor</cite>) – Output of the neural network.</p></li>
<li><p><strong>input_tensors</strong> (<cite>torch.Tensor</cite>) – Inputs to the neural network; i.e., sampled coordinates; i.e., independent variables.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The re-parameterized output of the network.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>torch.Tensor</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is <strong>abstract</strong> for BaseCondition</p>
</div>
</dd></dl>
<dl class="py method">
<dt id="neurodiffeq.conditions.NoCondition.set_impose_on"><a name="//apple_ref/cpp/Method/neurodiffeq.conditions.NoCondition.set_impose_on"></a>
<code class="sig-name descname">set_impose_on</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ith_unit</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.conditions.NoCondition.set_impose_on" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>[DEPRECATED]</strong> When training several functions with a single, multi-output network, this method is called
(by a <cite>Solver</cite> class or a <cite>solve</cite> function) to keep track of which output is being parameterized.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>ith_unit</strong> (<em>int</em>) – The index of network output to be parameterized.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is deprecated and retained for backward compatibility only. Users interested in enforcing
conditions on multi-output networks should consider using a <code class="docutils literal notranslate"><span class="pre">neurodiffeq.conditions.EnsembleCondition</span></code>.</p>
</div>
</dd></dl>
</dd></dl>
</div>
<div class="section" id="module-neurodiffeq.ode">
<span id="neurodiffeq-ode"></span><h2><a name="//apple_ref/cpp/Module/neurodiffeq.ode"></a><cite>neurodiffeq.ode</cite><a class="headerlink" href="#module-neurodiffeq.ode" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="neurodiffeq.ode.Monitor"><a name="//apple_ref/cpp/Class/neurodiffeq.ode.Monitor"></a>
<em class="property">class </em><code class="sig-prename descclassname">neurodiffeq.ode.</code><code class="sig-name descname">Monitor</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">t_min</span></em>, <em class="sig-param"><span class="n">t_max</span></em>, <em class="sig-param"><span class="n">check_every</span><span class="o">=</span><span class="default_value">100</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.ode.Monitor" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A monitor for checking the status of the neural network during training.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>t_min</strong> (<em>float</em>) – The lower bound of time domain that we want to monitor.</p></li>
<li><p><strong>t_max</strong> (<em>float</em>) – The upper bound of time domain that we want to monitor.</p></li>
<li><p><strong>check_every</strong> (<em>int</em><em>, </em><em>optional</em>) – The frequency of checking the neural network represented by the number of epochs between two checks, defaults to 100.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="neurodiffeq.ode.Monitor.check"><a name="//apple_ref/cpp/Method/neurodiffeq.ode.Monitor.check"></a>
<code class="sig-name descname">check</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">single_net</span></em>, <em class="sig-param"><span class="n">nets</span></em>, <em class="sig-param"><span class="n">conditions</span></em>, <em class="sig-param"><span class="n">history</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.ode.Monitor.check" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw 2 plots: One shows the shape of the current solution. The other shows the history training loss and validation loss.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nets</strong> (list[<cite>torch.nn.Module</cite>]) – The neural networks that approximates the ODE (system).</p></li>
<li><p><strong>conditions</strong> (list[<cite>neurodiffeq.ode.BaseCondition</cite>]) – The initial/boundary conditions of the ODE (system).</p></li>
<li><p><strong>history</strong> (<em>dict</em><em>[</em><em>'train': list</em><em>[</em><em>float</em><em>]</em><em>, </em><em>'valid': list</em><em>[</em><em>float</em><em>]</em><em>]</em>) – The history of training loss and validation loss. The ‘train_loss’ entry is a list of training loss and ‘valid_loss’ entry is a list of validation loss.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><cite>check</cite> is meant to be called by the function <cite>solve</cite> and <cite>solve_system</cite>.</p>
</div>
</dd></dl>
</dd></dl>
<dl class="py class">
<dt id="neurodiffeq.ode.Solution"><a name="//apple_ref/cpp/Class/neurodiffeq.ode.Solution"></a>
<em class="property">class </em><code class="sig-prename descclassname">neurodiffeq.ode.</code><code class="sig-name descname">Solution</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">single_net</span></em>, <em class="sig-param"><span class="n">nets</span></em>, <em class="sig-param"><span class="n">conditions</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.ode.Solution" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A solution to an ODE (system)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nets</strong> (list[<cite>torch.nn.Module</cite>]) – The neural networks that approximates the ODE.</p></li>
<li><p><strong>conditions</strong> (list[<cite>neurodiffeq.conditions.BaseCondition</cite>]) – The initial/boundary conditions of the ODE (system).</p></li>
</ul>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt id="neurodiffeq.ode.solve"><a name="//apple_ref/cpp/Function/neurodiffeq.ode.solve"></a>
<code class="sig-prename descclassname">neurodiffeq.ode.</code><code class="sig-name descname">solve</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ode</span></em>, <em class="sig-param"><span class="n">condition</span></em>, <em class="sig-param"><span class="n">t_min</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">t_max</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">net</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">train_generator</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">shuffle</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">valid_generator</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">optimizer</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">criterion</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">additional_loss_term</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">metrics</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">batch_size</span><span class="o">=</span><span class="default_value">16</span></em>, <em class="sig-param"><span class="n">max_epochs</span><span class="o">=</span><span class="default_value">1000</span></em>, <em class="sig-param"><span class="n">monitor</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">return_internal</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">return_best</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.ode.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Train a neural network to solve an ODE.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ode</strong> (<em>function</em>) – The ODE to solve. If the ODE is <span class="math notranslate nohighlight">\(F(x, t) = 0\)</span> where <span class="math notranslate nohighlight">\(x\)</span> is the dependent variable and <span class="math notranslate nohighlight">\(t\)</span> is the independent variable,
then <cite>ode</cite> should be a function that maps <span class="math notranslate nohighlight">\((x, t)\)</span> to <span class="math notranslate nohighlight">\(F(x, t)\)</span>.</p></li>
<li><p><strong>condition</strong> (<cite>neurodiffeq.conditions.BaseCondition</cite>) – The initial/boundary condition.</p></li>
<li><p><strong>net</strong> (<cite>torch.nn.Module</cite>, optional) – The neural network used to approximate the solution, defaults to None.</p></li>
<li><p><strong>t_min</strong> (<em>float</em>) – The lower bound of the domain (t) on which the ODE is solved, only needed when train_generator or valid_generator are not specified, defaults to None</p></li>
<li><p><strong>t_max</strong> (<em>float</em>) – The upper bound of the domain (t) on which the ODE is solved, only needed when train_generator or valid_generator are not specified, defaults to None</p></li>
<li><p><strong>train_generator</strong> (<cite>neurodiffeq.generator.Generator1D</cite>, optional) – The example generator to generate 1-D training points, default to None.</p></li>
<li><p><strong>shuffle</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to shuffle the training examples every epoch, defaults to True.</p></li>
<li><p><strong>valid_generator</strong> (<cite>neurodiffeq.generator.Generator1D</cite>, optional) – The example generator to generate 1-D validation points, default to None.</p></li>
<li><p><strong>optimizer</strong> (<cite>torch.optim.Optimizer</cite>, optional) – The optimization method to use for training, defaults to None.</p></li>
<li><p><strong>criterion</strong> (<cite>torch.nn.modules.loss._Loss</cite>, optional) – The loss function to use for training, defaults to None.</p></li>
<li><p><strong>additional_loss_term</strong> (<em>function</em>) – Extra terms to add to the loss function besides the part specified by <cite>criterion</cite>. The input of <cite>additional_loss_term</cite> should be the same as <cite>ode</cite></p></li>
<li><p><strong>metrics</strong> (<em>dict</em><em>[</em><em>string</em><em>, </em><em>function</em><em>]</em>) – Metrics to keep track of during training. The metrics should be passed as a dictionary where the keys are the names of the metrics, and the values are the corresponding function.
The input functions should be the same as <cite>ode</cite> and the output should be a numeric value. The metrics are evaluated on both the training set and validation set.</p></li>
<li><p><strong>batch_size</strong> (<em>int</em><em>, </em><em>optional</em>) – The size of the mini-batch to use, defaults to 16.</p></li>
<li><p><strong>max_epochs</strong> (<em>int</em><em>, </em><em>optional</em>) – The maximum number of epochs to train, defaults to 1000.</p></li>
<li><p><strong>monitor</strong> (<cite>neurodiffeq.ode.Monitor</cite>, optional) – The monitor to check the status of nerual network during training, defaults to None.</p></li>
<li><p><strong>return_internal</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to return the nets, conditions, training generator, validation generator, optimizer and loss function, defaults to False.</p></li>
<li><p><strong>return_best</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to return the nets that achieved the lowest validation loss, defaults to False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The solution of the ODE. The history of training loss and validation loss.
Optionally, the nets, conditions, training generator, validation generator, optimizer and loss function.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tuple[<cite>neurodiffeq.ode.Solution</cite>, dict]; or tuple[<cite>neurodiffeq.ode.Solution</cite>, dict, dict]</p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt id="neurodiffeq.ode.solve_system"><a name="//apple_ref/cpp/Function/neurodiffeq.ode.solve_system"></a>
<code class="sig-prename descclassname">neurodiffeq.ode.</code><code class="sig-name descname">solve_system</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ode_system</span></em>, <em class="sig-param"><span class="n">conditions</span></em>, <em class="sig-param"><span class="n">t_min</span></em>, <em class="sig-param"><span class="n">t_max</span></em>, <em class="sig-param"><span class="n">single_net</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">nets</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">train_generator</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">shuffle</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">valid_generator</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">optimizer</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">criterion</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">additional_loss_term</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">metrics</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">batch_size</span><span class="o">=</span><span class="default_value">16</span></em>, <em class="sig-param"><span class="n">max_epochs</span><span class="o">=</span><span class="default_value">1000</span></em>, <em class="sig-param"><span class="n">monitor</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">return_internal</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">return_best</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.ode.solve_system" title="Permalink to this definition">¶</a></dt>
<dd><p>Train a neural network to solve an ODE.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ode_system</strong> (<em>function</em>) – The ODE system to solve. If the ODE system consists of equations <span class="math notranslate nohighlight">\(F_i(x_1, x_2, ..., x_n, t) = 0\)</span> where <span class="math notranslate nohighlight">\(x_i\)</span> is the dependent i-th variable and <span class="math notranslate nohighlight">\(t\)</span> is the independent variable,
then <cite>ode_system</cite> should be a function that maps <span class="math notranslate nohighlight">\((x_1, x_2, ..., x_n, t)\)</span> to a list where the i-th entry is <span class="math notranslate nohighlight">\(F_i(x_1, x_2, ..., x_n, t)\)</span>.</p></li>
<li><p><strong>conditions</strong> (list[<cite>neurodiffeq.conditions.BaseCondition</cite>]) – The initial/boundary conditions. The ith entry of the conditions is the condition that <span class="math notranslate nohighlight">\(x_i\)</span> should satisfy.</p></li>
<li><p><strong>t_min</strong> (<em>float</em>) – The lower bound of the domain (t) on which the ODE is solved, only needed when train_generator or valid_generator are not specified, defaults to None</p></li>
<li><p><strong>t_max</strong> (<em>float</em>) – The upper bound of the domain (t) on which the ODE is solved, only needed when train_generator or valid_generator are not specified, defaults to None</p></li>
<li><p><strong>single_net</strong> – The single neural network used to approximate the solution. Only one of <cite>single_net</cite> and <cite>nets</cite> should be specified, defaults to None</p></li>
<li><p><strong>single_net</strong> – <cite>torch.nn.Module</cite>, optional</p></li>
<li><p><strong>nets</strong> (list[<cite>torch.nn.Module</cite>], optional) – The neural networks used to approximate the solution, defaults to None.</p></li>
<li><p><strong>train_generator</strong> (<cite>neurodiffeq.generator.Generator1D</cite>, optional) – The example generator to generate 1-D training points, default to None.</p></li>
<li><p><strong>shuffle</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to shuffle the training examples every epoch, defaults to True.</p></li>
<li><p><strong>valid_generator</strong> (<cite>neurodiffeq.generator.Generator1D</cite>, optional) – The example generator to generate 1-D validation points, default to None.</p></li>
<li><p><strong>optimizer</strong> (<cite>torch.optim.Optimizer</cite>, optional) – The optimization method to use for training, defaults to None.</p></li>
<li><p><strong>criterion</strong> (<cite>torch.nn.modules.loss._Loss</cite>, optional) – The loss function to use for training, defaults to None and sum of square of the output of <cite>ode_system</cite> will be used.</p></li>
<li><p><strong>additional_loss_term</strong> (<em>function</em>) – Extra terms to add to the loss function besides the part specified by <cite>criterion</cite>. The input of <cite>additional_loss_term</cite> should be the same as <cite>ode_system</cite></p></li>
<li><p><strong>metrics</strong> (<em>dict</em><em>[</em><em>string</em><em>, </em><em>function</em><em>]</em>) – Metrics to keep track of during training. The metrics should be passed as a dictionary where the keys are the names of the metrics, and the values are the corresponding function.
The input functions should be the same as <cite>ode_system</cite> and the output should be a numeric value. The metrics are evaluated on both the training set and validation set.</p></li>
<li><p><strong>batch_size</strong> (<em>int</em><em>, </em><em>optional</em>) – The size of the mini-batch to use, defaults to 16.</p></li>
<li><p><strong>max_epochs</strong> (<em>int</em><em>, </em><em>optional</em>) – The maximum number of epochs to train, defaults to 1000.</p></li>
<li><p><strong>monitor</strong> (<cite>neurodiffeq.ode.Monitor</cite>, optional) – The monitor to check the status of nerual network during training, defaults to None.</p></li>
<li><p><strong>return_internal</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to return the nets, conditions, training generator, validation generator, optimizer and loss function, defaults to False.</p></li>
<li><p><strong>return_best</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to return the nets that achieved the lowest validation loss, defaults to False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The solution of the ODE. The history of training loss and validation loss.
Optionally, the nets, conditions, training generator, validation generator, optimizer and loss function.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tuple[<cite>neurodiffeq.ode.Solution</cite>, dict]; or tuple[<cite>neurodiffeq.ode.Solution</cite>, dict, dict]</p>
</dd>
</dl>
</dd></dl>
</div>
<div class="section" id="module-neurodiffeq.pde">
<span id="neurodiffeq-pde"></span><h2><a name="//apple_ref/cpp/Module/neurodiffeq.pde"></a><cite>neurodiffeq.pde</cite><a class="headerlink" href="#module-neurodiffeq.pde" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="neurodiffeq.pde.CustomBoundaryCondition"><a name="//apple_ref/cpp/Class/neurodiffeq.pde.CustomBoundaryCondition"></a>
<em class="property">class </em><code class="sig-prename descclassname">neurodiffeq.pde.</code><code class="sig-name descname">CustomBoundaryCondition</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">center_point</span></em>, <em class="sig-param"><span class="n">dirichlet_control_points</span></em>, <em class="sig-param"><span class="n">neumann_control_points</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.pde.CustomBoundaryCondition" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#neurodiffeq.conditions.IrregularBoundaryCondition" title="neurodiffeq.conditions.IrregularBoundaryCondition"><code class="xref py py-class docutils literal notranslate"><span class="pre">neurodiffeq.conditions.IrregularBoundaryCondition</span></code></a></p>
<p>A boundary condition with irregular shape.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>center_point</strong> (<cite>pde.Point</cite>) – A point that roughly locate at the center of the domain. It will be used to sort the control points ‘clockwise’.</p></li>
<li><p><strong>dirichlet_control_points</strong> (<em>list</em><em>[</em><a class="reference internal" href="#neurodiffeq.pde.DirichletControlPoint" title="neurodiffeq.pde.DirichletControlPoint"><em>pde.DirichletControlPoint</em></a><em>]</em>) – a list of points on the Dirichlet boundary</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="neurodiffeq.pde.CustomBoundaryCondition.enforce"><a name="//apple_ref/cpp/Method/neurodiffeq.pde.CustomBoundaryCondition.enforce"></a>
<code class="sig-name descname">enforce</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">net</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">dimensions</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.pde.CustomBoundaryCondition.enforce" title="Permalink to this definition">¶</a></dt>
<dd><p>Enforces this condition on a network.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>net</strong> (<cite>torch.nn.Module</cite>) – The network whose output is to be re-parameterized.</p></li>
<li><p><strong>coordinates</strong> (<cite>torch.Tensor</cite>) – Inputs of the neural network.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The re-parameterized output, where the condition is automatically satisfied.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>torch.Tensor</cite></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="neurodiffeq.pde.CustomBoundaryCondition.in_domain"><a name="//apple_ref/cpp/Method/neurodiffeq.pde.CustomBoundaryCondition.in_domain"></a>
<code class="sig-name descname">in_domain</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">dimensions</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.pde.CustomBoundaryCondition.in_domain" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the coordinates (numpy.ndarray), the methods returns an boolean array indicating
whether the points lie within the domain.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>coordinates</strong> (<cite>numpy.ndarray</cite>) – Input tensors, each with shape (n_samples, 1).</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Whether each point lies within the domain.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>numpy.ndarray</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>This method is meant to be used by monitors for irregular domain visualization.</p></li>
</ul>
</div>
</dd></dl>
<dl class="py method">
<dt id="neurodiffeq.pde.CustomBoundaryCondition.parameterize"><a name="//apple_ref/cpp/Method/neurodiffeq.pde.CustomBoundaryCondition.parameterize"></a>
<code class="sig-name descname">parameterize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">output_tensor</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">input_tensors</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.pde.CustomBoundaryCondition.parameterize" title="Permalink to this definition">¶</a></dt>
<dd><p>Re-parameterizes output(s) of a network.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>output_tensor</strong> (<cite>torch.Tensor</cite>) – Output of the neural network.</p></li>
<li><p><strong>input_tensors</strong> (<cite>torch.Tensor</cite>) – Inputs to the neural network; i.e., sampled coordinates; i.e., independent variables.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The re-parameterized output of the network.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>torch.Tensor</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is <strong>abstract</strong> for BaseCondition</p>
</div>
</dd></dl>
<dl class="py method">
<dt id="neurodiffeq.pde.CustomBoundaryCondition.set_impose_on"><a name="//apple_ref/cpp/Method/neurodiffeq.pde.CustomBoundaryCondition.set_impose_on"></a>
<code class="sig-name descname">set_impose_on</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ith_unit</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.pde.CustomBoundaryCondition.set_impose_on" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>[DEPRECATED]</strong> When training several functions with a single, multi-output network, this method is called
(by a <cite>Solver</cite> class or a <cite>solve</cite> function) to keep track of which output is being parameterized.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>ith_unit</strong> (<em>int</em>) – The index of network output to be parameterized.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is deprecated and retained for backward compatibility only. Users interested in enforcing
conditions on multi-output networks should consider using a <code class="docutils literal notranslate"><span class="pre">neurodiffeq.conditions.EnsembleCondition</span></code>.</p>
</div>
</dd></dl>
</dd></dl>
<dl class="py class">
<dt id="neurodiffeq.pde.DirichletControlPoint"><a name="//apple_ref/cpp/Class/neurodiffeq.pde.DirichletControlPoint"></a>
<em class="property">class </em><code class="sig-prename descclassname">neurodiffeq.pde.</code><code class="sig-name descname">DirichletControlPoint</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">loc</span></em>, <em class="sig-param"><span class="n">val</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.pde.DirichletControlPoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#neurodiffeq.pde.Point" title="neurodiffeq.pde.Point"><code class="xref py py-class docutils literal notranslate"><span class="pre">neurodiffeq.pde.Point</span></code></a></p>
<p>A 2D point on the Dirichlet boundary.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>loc</strong> (<em>tuple</em><em>[</em><em>float</em><em>, </em><em>float</em><em>]</em>) – the location of the point in the form of <span class="math notranslate nohighlight">\((x, y)\)</span></p></li>
<li><p><strong>val</strong> (<em>float</em>) – the expected value of <span class="math notranslate nohighlight">\(u\)</span> at this location (<span class="math notranslate nohighlight">\(u(x, y)\)</span> is the function we are solving for)</p></li>
</ul>
</dd>
</dl>
</dd></dl>
<dl class="py class">
<dt id="neurodiffeq.pde.Monitor2D"><a name="//apple_ref/cpp/Class/neurodiffeq.pde.Monitor2D"></a>
<em class="property">class </em><code class="sig-prename descclassname">neurodiffeq.pde.</code><code class="sig-name descname">Monitor2D</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">xy_min</span></em>, <em class="sig-param"><span class="n">xy_max</span></em>, <em class="sig-param"><span class="n">check_every</span><span class="o">=</span><span class="default_value">100</span></em>, <em class="sig-param"><span class="n">valid_generator</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.pde.Monitor2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A monitor for checking the status of the neural network during training.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xy_min</strong> (<em>tuple</em><em>[</em><em>float</em><em>, </em><em>float</em><em>]</em><em>, </em><em>optional</em>) – The lower bound of 2 dimensions, if we only care about <span class="math notranslate nohighlight">\(x \geq x_0\)</span> and <span class="math notranslate nohighlight">\(y \geq y_0\)</span>, then <cite>xy_min</cite> is <cite>(x_0, y_0)</cite>.</p></li>
<li><p><strong>xy_max</strong> (<em>tuple</em><em>[</em><em>float</em><em>, </em><em>float</em><em>]</em><em>, </em><em>optional</em>) – The upper boound of 2 dimensions, if we only care about <span class="math notranslate nohighlight">\(x \leq x_1\)</span> and <span class="math notranslate nohighlight">\(y \leq y_1\)</span>, then <cite>xy_min</cite> is <cite>(x_1, y_1)</cite>.</p></li>
<li><p><strong>check_every</strong> (<em>int</em><em>, </em><em>optional</em>) – The frequency of checking the neural network represented by the number of epochs between two checks, defaults to 100.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="neurodiffeq.pde.Monitor2D.check"><a name="//apple_ref/cpp/Method/neurodiffeq.pde.Monitor2D.check"></a>
<code class="sig-name descname">check</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">single_net</span></em>, <em class="sig-param"><span class="n">nets</span></em>, <em class="sig-param"><span class="n">conditions</span></em>, <em class="sig-param"><span class="n">history</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.pde.Monitor2D.check" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw 2 plots: One shows the shape of the current solution (with heat map). The other shows the history training loss and validation loss.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>single_net</strong> (<cite>torch.nn.Module</cite>) – The neural network that approximates the PDE.</p></li>
<li><p><strong>nets</strong> (list [<cite>torch.nn.Module</cite>]) – The neural networks that approximates the PDE.</p></li>
<li><p><strong>conditions</strong> (list [<cite>neurodiffeq.conditions.BaseCondition</cite>]) – The initial/boundary condition of the PDE.</p></li>
<li><p><strong>history</strong> (<em>dict</em><em>[</em><em>'train': list</em><em>[</em><em>float</em><em>]</em><em>, </em><em>'valid': list</em><em>[</em><em>float</em><em>]</em><em>]</em>) – The history of training loss and validation loss. The ‘train’ entry is a list of training loss and ‘valid’ entry is a list of validation loss.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><cite>check</cite> is meant to be called by the function <cite>solve2D</cite>.</p>
</div>
</dd></dl>
</dd></dl>
<dl class="py class">
<dt id="neurodiffeq.pde.NeumannControlPoint"><a name="//apple_ref/cpp/Class/neurodiffeq.pde.NeumannControlPoint"></a>
<em class="property">class </em><code class="sig-prename descclassname">neurodiffeq.pde.</code><code class="sig-name descname">NeumannControlPoint</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">loc</span></em>, <em class="sig-param"><span class="n">val</span></em>, <em class="sig-param"><span class="n">normal_vector</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.pde.NeumannControlPoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#neurodiffeq.pde.Point" title="neurodiffeq.pde.Point"><code class="xref py py-class docutils literal notranslate"><span class="pre">neurodiffeq.pde.Point</span></code></a></p>
<p>A 2D point on the Neumann boundary.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>loc</strong> (<em>tuple</em><em>[</em><em>float</em><em>, </em><em>float</em><em>]</em>) – the location of the point in the form of <span class="math notranslate nohighlight">\((x, y)\)</span></p></li>
<li><p><strong>val</strong> (<em>float</em>) – the expected normal derivative of <span class="math notranslate nohighlight">\(u\)</span> at this location (<span class="math notranslate nohighlight">\(u(x, y)\)</span> is the function we are solving for)</p></li>
</ul>
</dd>
</dl>
</dd></dl>
<dl class="py class">
<dt id="neurodiffeq.pde.Point"><a name="//apple_ref/cpp/Class/neurodiffeq.pde.Point"></a>
<em class="property">class </em><code class="sig-prename descclassname">neurodiffeq.pde.</code><code class="sig-name descname">Point</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">loc</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.pde.Point" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A 2D point.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>loc</strong> (<em>tuple</em><em>[</em><em>float</em><em>, </em><em>float</em><em>]</em>) – the location of the point in the form of <span class="math notranslate nohighlight">\((x, y)\)</span></p>
</dd>
</dl>
</dd></dl>
<dl class="py class">
<dt id="neurodiffeq.pde.Solution"><a name="//apple_ref/cpp/Class/neurodiffeq.pde.Solution"></a>
<em class="property">class </em><code class="sig-prename descclassname">neurodiffeq.pde.</code><code class="sig-name descname">Solution</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">single_net</span></em>, <em class="sig-param"><span class="n">nets</span></em>, <em class="sig-param"><span class="n">conditions</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.pde.Solution" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A solution to an PDE (system)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>single_net</strong> (<cite>torch.nn.Module</cite>) – The neural networks that approximates the PDE.</p></li>
<li><p><strong>nets</strong> (list[<cite>torch.nn.Module</cite>]) – The neural networks that approximates the PDE.</p></li>
<li><p><strong>conditions</strong> (list[<cite>neurodiffeq.conditions.BaseCondition</cite>]) – The initial/boundary conditions of the ODE (system).</p></li>
</ul>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt id="neurodiffeq.pde.make_animation"><a name="//apple_ref/cpp/Function/neurodiffeq.pde.make_animation"></a>
<code class="sig-prename descclassname">neurodiffeq.pde.</code><code class="sig-name descname">make_animation</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">solution</span></em>, <em class="sig-param"><span class="n">xs</span></em>, <em class="sig-param"><span class="n">ts</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.pde.make_animation" title="Permalink to this definition">¶</a></dt>
<dd><p>Create animation of 1-D time-dependent problems.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>solution</strong> (<em>function</em>) – solution function returned by <cite>solve2D</cite> (for a 1-D time-dependent problem).</p></li>
<li><p><strong>xs</strong> (<cite>numpy.array</cite>) – The locations to evaluate solution.</p></li>
<li><p><strong>ts</strong> (<cite>numpy.array</cite>) – The time points to evaluate solution.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The animation.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>matplotlib.animation.FuncAnimation</cite></p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt id="neurodiffeq.pde.solve2D"><a name="//apple_ref/cpp/Function/neurodiffeq.pde.solve2D"></a>
<code class="sig-prename descclassname">neurodiffeq.pde.</code><code class="sig-name descname">solve2D</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pde</span></em>, <em class="sig-param"><span class="n">condition</span></em>, <em class="sig-param"><span class="n">xy_min</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">xy_max</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">net</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">train_generator</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">shuffle</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">valid_generator</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">optimizer</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">criterion</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">additional_loss_term</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">metrics</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">batch_size</span><span class="o">=</span><span class="default_value">16</span></em>, <em class="sig-param"><span class="n">max_epochs</span><span class="o">=</span><span class="default_value">1000</span></em>, <em class="sig-param"><span class="n">monitor</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">return_internal</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">return_best</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.pde.solve2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Train a neural network to solve a PDE with 2 independent variables.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pde</strong> (<em>function</em>) – The PDE to solve. If the PDE is <span class="math notranslate nohighlight">\(F(u, x, y) = 0\)</span> where <span class="math notranslate nohighlight">\(u\)</span> is the dependent variable and <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> are the independent variables,
then <cite>pde</cite> should be a function that maps <span class="math notranslate nohighlight">\((u, x, y)\)</span> to <span class="math notranslate nohighlight">\(F(u, x, y)\)</span>.</p></li>
<li><p><strong>condition</strong> (<cite>neurodiffeq.conditions.BaseCondition</cite>) – The initial/boundary condition.</p></li>
<li><p><strong>xy_min</strong> (<em>tuple</em><em>[</em><em>float</em><em>, </em><em>float</em><em>]</em><em>, </em><em>optional</em>) – The lower bound of 2 dimensions, if we only care about <span class="math notranslate nohighlight">\(x \geq x_0\)</span> and <span class="math notranslate nohighlight">\(y \geq y_0\)</span>, then <cite>xy_min</cite> is <cite>(x_0, y_0)</cite>, only needed when train_generator and valid_generator are not specified, defaults to None</p></li>
<li><p><strong>xy_max</strong> (<em>tuple</em><em>[</em><em>float</em><em>, </em><em>float</em><em>]</em><em>, </em><em>optional</em>) – The upper bound of 2 dimensions, if we only care about <span class="math notranslate nohighlight">\(x \leq x_1\)</span> and <span class="math notranslate nohighlight">\(y \leq y_1\)</span>, then <cite>xy_min</cite> is <cite>(x_1, y_1)</cite>, only needed when train_generator and valid_generator are not specified, defaults to None</p></li>
<li><p><strong>net</strong> (<cite>torch.nn.Module</cite>, optional) – The neural network used to approximate the solution, defaults to None.</p></li>
<li><p><strong>train_generator</strong> (<cite>neurodiffeq.generator.Generator2D</cite>, optional) – The example generator to generate 1-D training points, default to None.</p></li>
<li><p><strong>shuffle</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to shuffle the training examples every epoch, defaults to True.</p></li>
<li><p><strong>valid_generator</strong> (<cite>neurodiffeq.generator.Generator2D</cite>, optional) – The example generator to generate 1-D validation points, default to None.</p></li>
<li><p><strong>optimizer</strong> (<cite>torch.optim.Optimizer</cite>, optional) – The optimization method to use for training, defaults to None.</p></li>
<li><p><strong>criterion</strong> (<cite>torch.nn.modules.loss._Loss</cite>, optional) – The loss function to use for training, defaults to None.</p></li>
<li><p><strong>additional_loss_term</strong> (<em>function</em>) – Extra terms to add to the loss function besides the part specified by <cite>criterion</cite>. The input of <cite>additional_loss_term</cite> should be the same as <cite>pde_system</cite></p></li>
<li><p><strong>metrics</strong> (<em>dict</em><em>[</em><em>string</em><em>, </em><em>function</em><em>]</em>) – Metrics to keep track of during training. The metrics should be passed as a dictionary where the keys are the names of the metrics, and the values are the corresponding function.
The input functions should be the same as <cite>pde</cite> and the output should be a numeric value. The metrics are evaluated on both the training set and validation set.</p></li>
<li><p><strong>batch_size</strong> (<em>int</em><em>, </em><em>optional</em>) – The size of the mini-batch to use, defaults to 16.</p></li>
<li><p><strong>max_epochs</strong> (<em>int</em><em>, </em><em>optional</em>) – The maximum number of epochs to train, defaults to 1000.</p></li>
<li><p><strong>monitor</strong> (<cite>neurodiffeq.pde.Monitor2D</cite>, optional) – The monitor to check the status of nerual network during training, defaults to None.</p></li>
<li><p><strong>return_internal</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to return the nets, conditions, training generator, validation generator, optimizer and loss function, defaults to False.</p></li>
<li><p><strong>return_best</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to return the nets that achieved the lowest validation loss, defaults to False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The solution of the PDE. The history of training loss and validation loss.
Optionally, the nets, conditions, training generator, validation generator, optimizer and loss function.
The solution is a function that has the signature <cite>solution(xs, ys, as_type)</cite>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tuple[<cite>neurodiffeq.pde.Solution</cite>, dict]; or tuple[<cite>neurodiffeq.pde.Solution</cite>, dict, dict]</p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt id="neurodiffeq.pde.solve2D_system"><a name="//apple_ref/cpp/Function/neurodiffeq.pde.solve2D_system"></a>
<code class="sig-prename descclassname">neurodiffeq.pde.</code><code class="sig-name descname">solve2D_system</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pde_system</span></em>, <em class="sig-param"><span class="n">conditions</span></em>, <em class="sig-param"><span class="n">xy_min</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">xy_max</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">single_net</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">nets</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">train_generator</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">shuffle</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">valid_generator</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">optimizer</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">criterion</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">additional_loss_term</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">metrics</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">batch_size</span><span class="o">=</span><span class="default_value">16</span></em>, <em class="sig-param"><span class="n">max_epochs</span><span class="o">=</span><span class="default_value">1000</span></em>, <em class="sig-param"><span class="n">monitor</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">return_internal</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">return_best</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.pde.solve2D_system" title="Permalink to this definition">¶</a></dt>
<dd><p>Train a neural network to solve a PDE with 2 independent variables.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pde_system</strong> (<em>function</em>) – The PDEsystem to solve. If the PDE is <span class="math notranslate nohighlight">\(F_i(u_1, u_2, ..., u_n, x, y) = 0\)</span> where <span class="math notranslate nohighlight">\(u_i\)</span> is the i-th dependent variable and <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> are the independent variables,
then <cite>pde_system</cite> should be a function that maps <span class="math notranslate nohighlight">\((u_1, u_2, ..., u_n, x, y)\)</span> to a list where the i-th entry is <span class="math notranslate nohighlight">\(F_i(u_1, u_2, ..., u_n, x, y)\)</span>.</p></li>
<li><p><strong>conditions</strong> (list[<cite>neurodiffeq.conditions.BaseCondition</cite>]) – The initial/boundary conditions. The ith entry of the conditions is the condition that <span class="math notranslate nohighlight">\(x_i\)</span> should satisfy.</p></li>
<li><p><strong>xy_min</strong> (<em>tuple</em><em>[</em><em>float</em><em>, </em><em>float</em><em>]</em><em>, </em><em>optional</em>) – The lower bound of 2 dimensions, if we only care about <span class="math notranslate nohighlight">\(x \geq x_0\)</span> and <span class="math notranslate nohighlight">\(y \geq y_0\)</span>, then <cite>xy_min</cite> is <cite>(x_0, y_0)</cite>, only needed when train_generator or valid_generator are not specified, defaults to None</p></li>
<li><p><strong>xy_max</strong> (<em>tuple</em><em>[</em><em>float</em><em>, </em><em>float</em><em>]</em><em>, </em><em>optional</em>) – The upper bound of 2 dimensions, if we only care about <span class="math notranslate nohighlight">\(x \leq x_1\)</span> and <span class="math notranslate nohighlight">\(y \leq y_1\)</span>, then <cite>xy_min</cite> is <cite>(x_1, y_1)</cite>, only needed when train_generator or valid_generator are not specified, defaults to None</p></li>
<li><p><strong>single_net</strong> – The single neural network used to approximate the solution. Only one of <cite>single_net</cite> and <cite>nets</cite> should be specified, defaults to None</p></li>
<li><p><strong>single_net</strong> – <cite>torch.nn.Module</cite>, optional</p></li>
<li><p><strong>nets</strong> (list[<cite>torch.nn.Module</cite>], optional) – The neural networks used to approximate the solution, defaults to None.</p></li>
<li><p><strong>train_generator</strong> (<cite>neurodiffeq.generator.Generator2D</cite>, optional) – The example generator to generate 1-D training points, default to None.</p></li>
<li><p><strong>shuffle</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to shuffle the training examples every epoch, defaults to True.</p></li>
<li><p><strong>valid_generator</strong> (<cite>neurodiffeq.generator.Generator2D</cite>, optional) – The example generator to generate 1-D validation points, default to None.</p></li>
<li><p><strong>optimizer</strong> (<cite>torch.optim.Optimizer</cite>, optional) – The optimization method to use for training, defaults to None.</p></li>
<li><p><strong>criterion</strong> (<cite>torch.nn.modules.loss._Loss</cite>, optional) – The loss function to use for training, defaults to None.</p></li>
<li><p><strong>additional_loss_term</strong> (<em>function</em>) – Extra terms to add to the loss function besides the part specified by <cite>criterion</cite>. The input of <cite>additional_loss_term</cite> should be the same as <cite>pde_system</cite></p></li>
<li><p><strong>metrics</strong> (<em>dict</em><em>[</em><em>string</em><em>, </em><em>function</em><em>]</em>) – Metrics to keep track of during training. The metrics should be passed as a dictionary where the keys are the names of the metrics, and the values are the corresponding function.
The input functions should be the same as <cite>pde_system</cite> and the output should be a numeric value. The metrics are evaluated on both the training set and validation set.</p></li>
<li><p><strong>batch_size</strong> (<em>int</em><em>, </em><em>optional</em>) – The size of the mini-batch to use, defaults to 16.</p></li>
<li><p><strong>max_epochs</strong> (<em>int</em><em>, </em><em>optional</em>) – The maximum number of epochs to train, defaults to 1000.</p></li>
<li><p><strong>monitor</strong> (<cite>neurodiffeq.pde.Monitor2D</cite>, optional) – The monitor to check the status of nerual network during training, defaults to None.</p></li>
<li><p><strong>return_internal</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to return the nets, conditions, training generator, validation generator, optimizer and loss function, defaults to False.</p></li>
<li><p><strong>return_best</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to return the nets that achieved the lowest validation loss, defaults to False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The solution of the PDE. The history of training loss and validation loss.
Optionally, the nets, conditions, training generator, validation generator, optimizer and loss function.
The solution is a function that has the signature <cite>solution(xs, ys, as_type)</cite>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tuple[<cite>neurodiffeq.pde.Solution</cite>, dict]; or tuple[<cite>neurodiffeq.pde.Solution</cite>, dict, dict]</p>
</dd>
</dl>
</dd></dl>
</div>
<div class="section" id="module-neurodiffeq.pde_spherical">
<span id="neurodiffeq-pde-spherical"></span><h2><a name="//apple_ref/cpp/Module/neurodiffeq.pde_spherical"></a><cite>neurodiffeq.pde_spherical</cite><a class="headerlink" href="#module-neurodiffeq.pde_spherical" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="neurodiffeq.pde_spherical.MonitorCallback"><a name="//apple_ref/cpp/Class/neurodiffeq.pde_spherical.MonitorCallback"></a>
<em class="property">class </em><code class="sig-prename descclassname">neurodiffeq.pde_spherical.</code><code class="sig-name descname">MonitorCallback</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">monitor</span></em>, <em class="sig-param"><span class="n">fig_dir</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">check_against</span><span class="o">=</span><span class="default_value">'local'</span></em>, <em class="sig-param"><span class="n">repaint_last</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.pde_spherical.MonitorCallback" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A callback for updating the monitor plots (and optionally saving the fig to disk)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>monitor</strong> (<a class="reference internal" href="#neurodiffeq.pde_spherical.MonitorSpherical" title="neurodiffeq.pde_spherical.MonitorSpherical"><em>MonitorSpherical</em></a>) – the underlying monitor responsible for plotting solutions</p></li>
<li><p><strong>fig_dir</strong> (<em>str</em>) – directory for saving monitor figs; if not specified, figs will not be saved</p></li>
<li><p><strong>check_against</strong> (<em>str</em>) – which epoch count to check against; either ‘local’ (default) or ‘global’</p></li>
<li><p><strong>repaint_last</strong> (<em>bool</em>) – whether to update the plot on the last local epoch, defaults to True</p></li>
</ul>
</dd>
</dl>
</dd></dl>
<dl class="py class">
<dt id="neurodiffeq.pde_spherical.MonitorSpherical"><a name="//apple_ref/cpp/Class/neurodiffeq.pde_spherical.MonitorSpherical"></a>
<em class="property">class </em><code class="sig-prename descclassname">neurodiffeq.pde_spherical.</code><code class="sig-name descname">MonitorSpherical</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">r_min</span></em>, <em class="sig-param"><span class="n">r_max</span></em>, <em class="sig-param"><span class="n">check_every</span><span class="o">=</span><span class="default_value">100</span></em>, <em class="sig-param"><span class="n">var_names</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">shape</span><span class="o">=</span><span class="default_value">10, 10, 10</span></em>, <em class="sig-param"><span class="n">r_scale</span><span class="o">=</span><span class="default_value">'linear'</span></em>, <em class="sig-param"><span class="n">theta_min</span><span class="o">=</span><span class="default_value">0.0</span></em>, <em class="sig-param"><span class="n">theta_max</span><span class="o">=</span><span class="default_value">3.141592653589793</span></em>, <em class="sig-param"><span class="n">phi_min</span><span class="o">=</span><span class="default_value">0.0</span></em>, <em class="sig-param"><span class="n">phi_max</span><span class="o">=</span><span class="default_value">6.283185307179586</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.pde_spherical.MonitorSpherical" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A monitor for checking the status of the neural network during training.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>r_min</strong> (<em>float</em>) – The lower bound of radius, i.e., radius of interior boundary</p></li>
<li><p><strong>r_max</strong> (<em>float</em>) – The upper bound of radius, i.e., radius of exterior boundary</p></li>
<li><p><strong>check_every</strong> (<em>int</em><em>, </em><em>optional</em>) – The frequency of checking the neural network represented by the number of epochs between two checks, defaults to 100.</p></li>
<li><p><strong>var_names</strong> (<em>list</em><em>[</em><em>str</em><em>]</em>) – names of dependent variables; if provided, shall be used for plot titles; defaults to None</p></li>
<li><p><strong>shape</strong> (<em>tuple</em><em>[</em><em>int</em><em>]</em>) – shape of mesh for visualizing the solution; defaults to (10, 10, 10)</p></li>
<li><p><strong>r_scale</strong> (<em>str</em>) – ‘linear’ or ‘log’; controls the grid point in the <span class="math notranslate nohighlight">\(r\)</span> direction; defaults to ‘linear’</p></li>
<li><p><strong>theta_min</strong> (<em>float</em>) – The lower bound of polar angle, defaults to <span class="math notranslate nohighlight">\(0\)</span></p></li>
<li><p><strong>theta_max</strong> (<em>float</em>) – The upper bound of polar angle, defaults to <span class="math notranslate nohighlight">\(\pi\)</span></p></li>
<li><p><strong>phi_min</strong> (<em>float</em>) – The lower bound of azimuthal angle, defaults to <span class="math notranslate nohighlight">\(0\)</span></p></li>
<li><p><strong>phi_max</strong> (<em>float</em>) – The upper bound of azimuthal angle, defaults to <span class="math notranslate nohighlight">\(2\pi\)</span></p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="neurodiffeq.pde_spherical.MonitorSpherical.check"><a name="//apple_ref/cpp/Method/neurodiffeq.pde_spherical.MonitorSpherical.check"></a>
<code class="sig-name descname">check</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">nets</span></em>, <em class="sig-param"><span class="n">conditions</span></em>, <em class="sig-param"><span class="n">loss_history</span></em>, <em class="sig-param"><span class="n">analytic_mse_history</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.pde_spherical.MonitorSpherical.check" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Draw (3n + 2) plots:</dt><dd><ol class="arabic simple">
<li><p>For each function u(r, phi, theta), there are 3 axes:
a) one ax for u-r curves grouped by phi
b) one ax for u-r curves grouped by theta
c) one ax for u-theta-phi contour heat map</p></li>
<li><p>Additionally, one ax for MSE against analytic solution, another for training and validation loss</p></li>
</ol>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nets</strong> (list [<cite>torch.nn.Module</cite>]) – The neural networks that approximates the PDE.</p></li>
<li><p><strong>conditions</strong> (list [<cite>neurodiffeq.conditions.BaseCondition</cite>]) – The initial/boundary condition of the PDE.</p></li>
<li><p><strong>loss_history</strong> (<em>dict</em><em>[</em><em>'train': list</em><em>[</em><em>float</em><em>]</em><em>, </em><em>'valid': list</em><em>[</em><em>float</em><em>]</em><em>]</em>) – The history of training loss and validation loss. The ‘train’ entry is a list of training loss and ‘valid’ entry is a list of validation loss.</p></li>
<li><p><strong>analytic_mse_history</strong> (<em>dict</em><em>[</em><em>'train': list</em><em>[</em><em>float</em><em>]</em><em>, </em><em>'valid': list</em><em>[</em><em>float</em><em>]</em><em>]</em>) – The history of training and validation MSE against analytic solution. The ‘train’ entry is a list of training analytic MSE and ‘valid’ entry is a list of validation analytic MSE.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><cite>check</cite> is meant to be called by the function <cite>solve2D</cite>.</p>
</div>
</dd></dl>
<dl class="py method">
<dt id="neurodiffeq.pde_spherical.MonitorSpherical.customization"><a name="//apple_ref/cpp/Method/neurodiffeq.pde_spherical.MonitorSpherical.customization"></a>
<code class="sig-name descname">customization</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.pde_spherical.MonitorSpherical.customization" title="Permalink to this definition">¶</a></dt>
<dd><p>Customized tweaks can be implemented by overwriting this method.</p>
</dd></dl>
<dl class="py method">
<dt id="neurodiffeq.pde_spherical.MonitorSpherical.set_variable_count"><a name="//apple_ref/cpp/Method/neurodiffeq.pde_spherical.MonitorSpherical.set_variable_count"></a>
<code class="sig-name descname">set_variable_count</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.pde_spherical.MonitorSpherical.set_variable_count" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Manually set the number of scalar fields to be visualized;</dt><dd><p>If not set, defaults to length of <cite>nets</cite> passed to <cite>self.check()</cite> every time <cite>self.check()</cite> is called</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>n</strong> (<em>int</em>) – number of scalar fields to overwrite default</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="neurodiffeq.pde_spherical.MonitorSpherical.unset_variable_count"><a name="//apple_ref/cpp/Method/neurodiffeq.pde_spherical.MonitorSpherical.unset_variable_count"></a>
<code class="sig-name descname">unset_variable_count</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.pde_spherical.MonitorSpherical.unset_variable_count" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Manually unset the number of scalar fields to be visualized;</dt><dd><p>Once unset, the number defaults to length of <cite>nets</cite> passed to <cite>self.check()</cite> every time <cite>self.check()</cite> is called</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>self</p>
</dd>
</dl>
</dd></dl>
</dd></dl>
<dl class="py class">
<dt id="neurodiffeq.pde_spherical.MonitorSphericalHarmonics"><a name="//apple_ref/cpp/Class/neurodiffeq.pde_spherical.MonitorSphericalHarmonics"></a>
<em class="property">class </em><code class="sig-prename descclassname">neurodiffeq.pde_spherical.</code><code class="sig-name descname">MonitorSphericalHarmonics</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">r_min</span></em>, <em class="sig-param"><span class="n">r_max</span></em>, <em class="sig-param"><span class="n">check_every</span><span class="o">=</span><span class="default_value">100</span></em>, <em class="sig-param"><span class="n">var_names</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">shape</span><span class="o">=</span><span class="default_value">10, 10, 10</span></em>, <em class="sig-param"><span class="n">r_scale</span><span class="o">=</span><span class="default_value">'linear'</span></em>, <em class="sig-param"><span class="n">harmonics_fn</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">theta_min</span><span class="o">=</span><span class="default_value">0.0</span></em>, <em class="sig-param"><span class="n">theta_max</span><span class="o">=</span><span class="default_value">3.141592653589793</span></em>, <em class="sig-param"><span class="n">phi_min</span><span class="o">=</span><span class="default_value">0.0</span></em>, <em class="sig-param"><span class="n">phi_max</span><span class="o">=</span><span class="default_value">6.283185307179586</span></em>, <em class="sig-param"><span class="n">max_degree</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.pde_spherical.MonitorSphericalHarmonics" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#neurodiffeq.pde_spherical.MonitorSpherical" title="neurodiffeq.pde_spherical.MonitorSpherical"><code class="xref py py-class docutils literal notranslate"><span class="pre">neurodiffeq.pde_spherical.MonitorSpherical</span></code></a></p>
<p>A monitor for checking the status of the neural network during training.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>r_min</strong> (<em>float</em>) – The lower bound of radius, i.e., radius of interior boundary</p></li>
<li><p><strong>r_max</strong> (<em>float</em>) – The upper bound of radius, i.e., radius of exterior boundary</p></li>
<li><p><strong>check_every</strong> (<em>int</em><em>, </em><em>optional</em>) – The frequency of checking the neural network represented by the number of epochs between two checks, defaults to 100.</p></li>
<li><p><strong>var_names</strong> (<em>list</em><em>[</em><em>str</em><em>]</em>) – names of dependent variables; if provided, shall be used for plot titles; defaults to None</p></li>
<li><p><strong>shape</strong> (<em>tuple</em><em>[</em><em>int</em><em>]</em>) – shape of mesh for visualizing the solution; defaults to (10, 10, 10)</p></li>
<li><p><strong>r_scale</strong> (<em>str</em>) – ‘linear’ or ‘log’; controls the grid point in the <span class="math notranslate nohighlight">\(r\)</span> direction; defaults to ‘linear’</p></li>
<li><p><strong>harmonics_fn</strong> (<em>callable</em>) – mapping from <span class="math notranslate nohighlight">\(\theta\)</span> and <span class="math notranslate nohighlight">\(\phi\)</span> to basis functions, e.g., spherical harmonics</p></li>
<li><p><strong>theta_min</strong> (<em>float</em>) – The lower bound of polar angle, defaults to <span class="math notranslate nohighlight">\(0\)</span></p></li>
<li><p><strong>theta_max</strong> (<em>float</em>) – The upper bound of polar angle, defaults to <span class="math notranslate nohighlight">\(\pi\)</span></p></li>
<li><p><strong>phi_min</strong> (<em>float</em>) – The lower bound of azimuthal angle, defaults to <span class="math notranslate nohighlight">\(0\)</span></p></li>
<li><p><strong>phi_max</strong> (<em>float</em>) – The upper bound of azimuthal angle, defaults to <span class="math notranslate nohighlight">\(2\pi\)</span></p></li>
<li><p><strong>max_degree</strong> (<em>int</em>) – DEPRECATED and SUPERSEDED by harmonics_fn; highest used for the harmonic basis</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="neurodiffeq.pde_spherical.MonitorSphericalHarmonics.check"><a name="//apple_ref/cpp/Method/neurodiffeq.pde_spherical.MonitorSphericalHarmonics.check"></a>
<code class="sig-name descname">check</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">nets</span></em>, <em class="sig-param"><span class="n">conditions</span></em>, <em class="sig-param"><span class="n">loss_history</span></em>, <em class="sig-param"><span class="n">analytic_mse_history</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.pde_spherical.MonitorSphericalHarmonics.check" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Draw (3n + 2) plots:</dt><dd><ol class="arabic simple">
<li><p>For each function u(r, phi, theta), there are 3 axes:
a) one ax for u-r curves grouped by phi
b) one ax for u-r curves grouped by theta
c) one ax for u-theta-phi contour heat map</p></li>
<li><p>Additionally, one ax for MSE against analytic solution, another for training and validation loss</p></li>
</ol>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nets</strong> (list [<cite>torch.nn.Module</cite>]) – The neural networks that approximates the PDE.</p></li>
<li><p><strong>conditions</strong> (list [<cite>neurodiffeq.conditions.BaseCondition</cite>]) – The initial/boundary condition of the PDE.</p></li>
<li><p><strong>loss_history</strong> (<em>dict</em><em>[</em><em>'train': list</em><em>[</em><em>float</em><em>]</em><em>, </em><em>'valid': list</em><em>[</em><em>float</em><em>]</em><em>]</em>) – The history of training loss and validation loss. The ‘train’ entry is a list of training loss and ‘valid’ entry is a list of validation loss.</p></li>
<li><p><strong>analytic_mse_history</strong> (<em>dict</em><em>[</em><em>'train': list</em><em>[</em><em>float</em><em>]</em><em>, </em><em>'valid': list</em><em>[</em><em>float</em><em>]</em><em>]</em>) – The history of training and validation MSE against analytic solution. The ‘train’ entry is a list of training analytic MSE and ‘valid’ entry is a list of validation analytic MSE.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><cite>check</cite> is meant to be called by the function <cite>solve2D</cite>.</p>
</div>
</dd></dl>
<dl class="py method">
<dt id="neurodiffeq.pde_spherical.MonitorSphericalHarmonics.customization"><a name="//apple_ref/cpp/Method/neurodiffeq.pde_spherical.MonitorSphericalHarmonics.customization"></a>
<code class="sig-name descname">customization</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.pde_spherical.MonitorSphericalHarmonics.customization" title="Permalink to this definition">¶</a></dt>
<dd><p>Customized tweaks can be implemented by overwriting this method.</p>
</dd></dl>
<dl class="py method">
<dt id="neurodiffeq.pde_spherical.MonitorSphericalHarmonics.set_variable_count"><a name="//apple_ref/cpp/Method/neurodiffeq.pde_spherical.MonitorSphericalHarmonics.set_variable_count"></a>
<code class="sig-name descname">set_variable_count</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.pde_spherical.MonitorSphericalHarmonics.set_variable_count" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Manually set the number of scalar fields to be visualized;</dt><dd><p>If not set, defaults to length of <cite>nets</cite> passed to <cite>self.check()</cite> every time <cite>self.check()</cite> is called</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>n</strong> (<em>int</em>) – number of scalar fields to overwrite default</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="neurodiffeq.pde_spherical.MonitorSphericalHarmonics.unset_variable_count"><a name="//apple_ref/cpp/Method/neurodiffeq.pde_spherical.MonitorSphericalHarmonics.unset_variable_count"></a>
<code class="sig-name descname">unset_variable_count</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.pde_spherical.MonitorSphericalHarmonics.unset_variable_count" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Manually unset the number of scalar fields to be visualized;</dt><dd><p>Once unset, the number defaults to length of <cite>nets</cite> passed to <cite>self.check()</cite> every time <cite>self.check()</cite> is called</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>self</p>
</dd>
</dl>
</dd></dl>
</dd></dl>
<dl class="py class">
<dt id="neurodiffeq.pde_spherical.SolutionSpherical"><a name="//apple_ref/cpp/Class/neurodiffeq.pde_spherical.SolutionSpherical"></a>
<em class="property">class </em><code class="sig-prename descclassname">neurodiffeq.pde_spherical.</code><code class="sig-name descname">SolutionSpherical</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">nets</span></em>, <em class="sig-param"><span class="n">conditions</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.pde_spherical.SolutionSpherical" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A solution to a PDE (system) in spherical coordinates</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nets</strong> (list[<cite>torch.nn.Module</cite>]) – The neural networks that approximate the PDE.</p></li>
<li><p><strong>conditions</strong> (list[<cite>neurodiffeq.conditions.BaseCondition</cite>]) – The conditions of the PDE (system).</p></li>
</ul>
</dd>
</dl>
</dd></dl>
<dl class="py class">
<dt id="neurodiffeq.pde_spherical.SolutionSphericalHarmonics"><a name="//apple_ref/cpp/Class/neurodiffeq.pde_spherical.SolutionSphericalHarmonics"></a>
<em class="property">class </em><code class="sig-prename descclassname">neurodiffeq.pde_spherical.</code><code class="sig-name descname">SolutionSphericalHarmonics</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">nets</span></em>, <em class="sig-param"><span class="n">conditions</span></em>, <em class="sig-param"><span class="n">max_degree</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">harmonics_fn</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.pde_spherical.SolutionSphericalHarmonics" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#neurodiffeq.pde_spherical.SolutionSpherical" title="neurodiffeq.pde_spherical.SolutionSpherical"><code class="xref py py-class docutils literal notranslate"><span class="pre">neurodiffeq.pde_spherical.SolutionSpherical</span></code></a></p>
<p>A solution to a PDE (system) in spherical coordinates</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nets</strong> (list[<cite>torch.nn.Module</cite>]) – list of networks that takes in radius tensor and outputs the coefficients of spherical harmonics</p></li>
<li><p><strong>conditions</strong> (list[<cite>neurodiffeq.conditions.BaseCondition</cite>]) – list of conditions to be enforced on each nets; must be of the same length as nets</p></li>
<li><p><strong>harmonics_fn</strong> (<em>callable</em>) – mapping from <span class="math notranslate nohighlight">\(\theta\)</span> and <span class="math notranslate nohighlight">\(\phi\)</span> to basis functions, e.g., spherical harmonics</p></li>
<li><p><strong>max_degree</strong> (<em>int</em>) – DEPRECATED and SUPERSEDED by harmonics_fn; highest used for the harmonic basis</p></li>
</ul>
</dd>
</dl>
</dd></dl>
<dl class="py class">
<dt id="neurodiffeq.pde_spherical.SphericalSolver"><a name="//apple_ref/cpp/Class/neurodiffeq.pde_spherical.SphericalSolver"></a>
<em class="property">class </em><code class="sig-prename descclassname">neurodiffeq.pde_spherical.</code><code class="sig-name descname">SphericalSolver</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pde_system</span></em>, <em class="sig-param"><span class="n">conditions</span></em>, <em class="sig-param"><span class="n">r_min</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">r_max</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">nets</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">train_generator</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">valid_generator</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">analytic_solutions</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">optimizer</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">criterion</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">n_batches_train</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">n_batches_valid</span><span class="o">=</span><span class="default_value">4</span></em>, <em class="sig-param"><span class="n">enforcer</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">shuffle</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">batch_size</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.pde_spherical.SphericalSolver" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A solver class for solving PDEs in spherical coordinates</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pde_system</strong> (<em>callable</em>) – the PDE system to solve; maps a tuple of three coordinates to a tuple of PDE residuals, both the coordinates and PDE residuals must have shape (-1, 1)</p></li>
<li><p><strong>conditions</strong> (list[<cite>neurodiffeq.conditions.BaseCondition</cite>]) – list of boundary conditions for each target function</p></li>
<li><p><strong>r_min</strong> (<em>float</em>) – radius for inner boundary; ignored if train_generator and valid_generator are both set; r_min &gt; 0; optional</p></li>
<li><p><strong>r_max</strong> (<em>float</em>) – radius for outer boundary; ignored if train_generator and valid_generator are both set; r_max &gt; r_min; optional</p></li>
<li><p><strong>nets</strong> (<em>list</em><em>[</em><em>torch.nn.Module</em><em>]</em>) – list of neural networks for parameterized solution; if provided, length must equal that of conditions; optional</p></li>
<li><p><strong>train_generator</strong> (<cite>neurodiffeq.pde_spherical.BaseGenerator</cite>) – generator for sampling training points, must provide a .get_examples() method and a .size field; optional</p></li>
<li><p><strong>valid_generator</strong> (<cite>neurodiffeq.pde_spherical.BaseGenerator</cite>) – generator for sampling validation points, must provide a .get_examples() method and a .size field; optional</p></li>
<li><p><strong>analytic_solutions</strong> (<em>callable</em>) – analytical solutions to be compared with neural net solutions; maps a tuple of three coordinates to a tuple of function values; output shape shoule match that of networks; optional</p></li>
<li><p><strong>optimizer</strong> (<em>torch.nn.optim.Optimizer</em>) – optimizer to be used for training; optional</p></li>
<li><p><strong>criterion</strong> (<em>callable</em>) – function that maps a PDE residual vector (torch tensor with shape (-1, 1)) to a scalar loss; optional</p></li>
<li><p><strong>n_batches_train</strong> (<em>int</em>) – number of batches to train in every epoch; where batch-size equals train_generator.size</p></li>
<li><p><strong>n_batches_valid</strong> (<em>int</em>) – number of batches to valid in every epoch; where batch-size equals valid_generator.size</p></li>
<li><p><strong>enforcer</strong> (<em>callable</em>) – a function mapping a network, a condition, and a batch (returned by a generator) to the function values evaluated on the batch</p></li>
<li><p><strong>batch_size</strong> (<em>int</em>) – DEPRECATED and IGNORED; each batch will use all samples generated, specify n_batches_train and n_batches_valid instead</p></li>
<li><p><strong>shuffle</strong> (<em>bool</em>) – deprecated; shuffling should be performed by generators</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="neurodiffeq.pde_spherical.SphericalSolver.additional_loss"><a name="//apple_ref/cpp/Method/neurodiffeq.pde_spherical.SphericalSolver.additional_loss"></a>
<code class="sig-name descname">additional_loss</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">funcs</span></em>, <em class="sig-param"><span class="n">key</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.pde_spherical.SphericalSolver.additional_loss" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Return additional loss; this method is to be overridden by subclasses</dt><dd><p>This method can use any of the internal variables: the current batch, the nets, the conditions, etc.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>funcs</strong> (<em>list</em><em>[</em><em>torch.Tensor</em><em>]</em>) – outputs of the networks after enforced by conditions</p></li>
<li><p><strong>key</strong> (<em>str</em>) – {‘train’, ‘valid’}; phase of the epoch; used to access the sample batch, etc.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>additional scalar loss</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>torch.Tensor</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="neurodiffeq.pde_spherical.SphericalSolver.fit"><a name="//apple_ref/cpp/Method/neurodiffeq.pde_spherical.SphericalSolver.fit"></a>
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">max_epochs</span></em>, <em class="sig-param"><span class="n">callbacks</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">monitor</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.pde_spherical.SphericalSolver.fit" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Run multiple epochs of training and validation, update best loss at the end of each epoch.</dt><dd><p>This method does not return solution, which is done in the <cite>.get_solution</cite> method.
If <cite>callbacks</cite> is passed, callbacks are run one at a time, after training, validating, updaing best model and before monitor checking
A callback function <cite>cb(solver)</cite> can set <cite>solver._stop_training</cite> to True to perform early stopping,</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>max_epochs</strong> (<em>int</em>) – number of epochs to run</p></li>
<li><p><strong>monitor</strong> – DEPRECATED; use a MonitorCallback instance instead; Monitor for visualizing solution and metrics</p></li>
<li><p><strong>callbacks</strong> – a list of callback functions, each accepting the solver instance itself as its only argument</p></li>
</ul>
</dd>
<dt class="field-even">Rtype monitor</dt>
<dd class="field-even"><p><cite>neurodiffeq.pde_spherical.MonitorSpherical</cite></p>
</dd>
<dt class="field-odd">Rtype callbacks</dt>
<dd class="field-odd"><p>list[callable]</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="neurodiffeq.pde_spherical.SphericalSolver.get_internals"><a name="//apple_ref/cpp/Method/neurodiffeq.pde_spherical.SphericalSolver.get_internals"></a>
<code class="sig-name descname">get_internals</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">param_names</span></em>, <em class="sig-param"><span class="n">return_type</span><span class="o">=</span><span class="default_value">'list'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.pde_spherical.SphericalSolver.get_internals" title="Permalink to this definition">¶</a></dt>
<dd><p>Return internal variable(s) of the solver
If param_names == ‘all’, return all internal variables as a dict;
If param_names is single str, return the corresponding variables
If param_names is a list and return_type == ‘list’, return corresponding internal variables as a list
If param_names is a list and return_type == ‘dict’, return a dict with keys in param_names</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>param_names</strong> (<em>str</em><em> or </em><em>list</em><em>[</em><em>str</em><em>]</em>) – a parameter name or a list of parameter names</p></li>
<li><p><strong>return_type</strong> (<em>str</em>) – {‘list’, ‘dict’}; ignored if <cite>param_names</cite> is a str</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a single parameter, or a list/dict of parameters as indicated above</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list or dict or any</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="neurodiffeq.pde_spherical.SphericalSolver.get_solution"><a name="//apple_ref/cpp/Method/neurodiffeq.pde_spherical.SphericalSolver.get_solution"></a>
<code class="sig-name descname">get_solution</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">copy</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">best</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">harmonics_fn</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.pde_spherical.SphericalSolver.get_solution" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a solution class</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>copy</strong> (<em>bool</em>) – if True, use a deep copy of internal nets and conditions</p></li>
<li><p><strong>best</strong> (<em>bool</em>) – if True, return the solution with lowest loss instead of the solution after the last epoch</p></li>
<li><p><strong>harmonics_fn</strong> (<em>callable</em>) – if set, use it as function basis for returned solution</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>trained solution</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>neurodiffeq.pde_spherical.SolutionSpherical</cite></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="neurodiffeq.pde_spherical.SphericalSolver.global_epoch"><a name="//apple_ref/cpp/Method/neurodiffeq.pde_spherical.SphericalSolver.global_epoch"></a>
<em class="property">property </em><code class="sig-name descname">global_epoch</code><a class="headerlink" href="#neurodiffeq.pde_spherical.SphericalSolver.global_epoch" title="Permalink to this definition">¶</a></dt>
<dd><p>Global epoch count, always equal to the length of train loss history</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>number of training epochs that have been run</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>int</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="neurodiffeq.pde_spherical.SphericalSolver.run_train_epoch"><a name="//apple_ref/cpp/Method/neurodiffeq.pde_spherical.SphericalSolver.run_train_epoch"></a>
<code class="sig-name descname">run_train_epoch</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.pde_spherical.SphericalSolver.run_train_epoch" title="Permalink to this definition">¶</a></dt>
<dd><p>Run a training epoch, update history, and perform gradient descent</p>
</dd></dl>
<dl class="py method">
<dt id="neurodiffeq.pde_spherical.SphericalSolver.run_valid_epoch"><a name="//apple_ref/cpp/Method/neurodiffeq.pde_spherical.SphericalSolver.run_valid_epoch"></a>
<code class="sig-name descname">run_valid_epoch</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.pde_spherical.SphericalSolver.run_valid_epoch" title="Permalink to this definition">¶</a></dt>
<dd><p>Run a validation epoch and update history</p>
</dd></dl>
</dd></dl>
<dl class="py function">
<dt id="neurodiffeq.pde_spherical.solve_spherical"><a name="//apple_ref/cpp/Function/neurodiffeq.pde_spherical.solve_spherical"></a>
<code class="sig-prename descclassname">neurodiffeq.pde_spherical.</code><code class="sig-name descname">solve_spherical</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pde</span></em>, <em class="sig-param"><span class="n">condition</span></em>, <em class="sig-param"><span class="n">r_min</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">r_max</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">net</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">train_generator</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">shuffle</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">valid_generator</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">analytic_solution</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">optimizer</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">criterion</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">batch_size</span><span class="o">=</span><span class="default_value">16</span></em>, <em class="sig-param"><span class="n">max_epochs</span><span class="o">=</span><span class="default_value">1000</span></em>, <em class="sig-param"><span class="n">monitor</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">return_internal</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">return_best</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">harmonics_fn</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.pde_spherical.solve_spherical" title="Permalink to this definition">¶</a></dt>
<dd><p>[DEPRECATED, use SphericalSolver class instead] Train a neural network to solve one PDE with spherical inputs in 3D space</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pde</strong> (<em>callable</em>) – The PDE to solve. If the PDE is <span class="math notranslate nohighlight">\(F(u, r,\theta, \phi) = 0\)</span> where <span class="math notranslate nohighlight">\(u\)</span> is the dependent variable and <span class="math notranslate nohighlight">\(r\)</span>, <span class="math notranslate nohighlight">\(\theta\)</span> and <span class="math notranslate nohighlight">\(\phi\)</span> are the independent variables,
then <cite>pde</cite> should be a function that maps <span class="math notranslate nohighlight">\((u, r, \theta, \phi)\)</span> to <span class="math notranslate nohighlight">\(F(u, r,\theta, \phi)\)</span></p></li>
<li><p><strong>condition</strong> (<cite>neurodiffeq.conditions.BaseCondition</cite>) – The initial/boundary condition that <span class="math notranslate nohighlight">\(u\)</span> should satisfy.</p></li>
<li><p><strong>r_min</strong> (<em>float</em>) – radius for inner boundary; ignored if both generators are provided; optional</p></li>
<li><p><strong>r_max</strong> (<em>float</em>) – radius for outer boundary; ignored if both generators are provided; optional</p></li>
<li><p><strong>net</strong> (<cite>torch.nn.Module</cite>, optional) – The neural network used to approximate the solution, defaults to None.</p></li>
<li><p><strong>train_generator</strong> (<cite>neurodiffeq.pde_spherical.BaseGenerator</cite>, optional) – The example generator to generate 3-D training points, default to None.</p></li>
<li><p><strong>valid_generator</strong> (<cite>neurodiffeq.pde_spherical.BaseGenerator</cite>, optional) – The example generator to generate 3-D validation points, default to None.</p></li>
<li><p><strong>shuffle</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to shuffle the training examples every epoch, defaults to True.</p></li>
<li><p><strong>analytic_solution</strong> (<em>callable</em>) – analytic solution to the pde system, used for testing purposes; should map (rs, thetas, phis) to u</p></li>
<li><p><strong>optimizer</strong> (<cite>torch.optim.Optimizer</cite>, optional) – The optimization method to use for training, defaults to None.</p></li>
<li><p><strong>criterion</strong> (<cite>torch.nn.modules.loss._Loss</cite>, optional) – The loss function to use for training, defaults to None.</p></li>
<li><p><strong>batch_size</strong> (<em>int</em><em>, </em><em>optional</em>) – The size of the mini-batch to use, defaults to 16.</p></li>
<li><p><strong>max_epochs</strong> (<em>int</em><em>, </em><em>optional</em>) – The maximum number of epochs to train, defaults to 1000.</p></li>
<li><p><strong>monitor</strong> (<cite>neurodiffeq.pde_spherical.MonitorSpherical</cite>, optional) – The monitor to check the status of neural network during training, defaults to None.</p></li>
<li><p><strong>return_internal</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to return the nets, conditions, training generator, validation generator, optimizer and loss function, defaults to False.</p></li>
<li><p><strong>return_best</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to return the nets that achieved the lowest validation loss, defaults to False.</p></li>
<li><p><strong>harmonics_fn</strong> (<em>callable</em>) – function basis (spherical harmonics for example) if solving coefficients of a function basis; used when returning solution</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The solution of the PDE. The history of training loss and validation loss.
Optionally, MSE against analytic solution, the nets, conditions, training generator, validation generator, optimizer and loss function.
The solution is a function that has the signature <cite>solution(xs, ys, as_type)</cite>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tuple[<cite>neurodiffeq.pde_spherical.SolutionSpherical</cite>, dict]; or tuple[<cite>neurodiffeq.pde_spherical.SolutionSpherical</cite>, dict, dict]; or tuple[<cite>neurodiffeq.pde_spherical.SolutionSpherical</cite>, dict, dict, dict]</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function is deprecated, use a <cite>SphericalSolver</cite> instead</p>
</div>
</dd></dl>
<dl class="py function">
<dt id="neurodiffeq.pde_spherical.solve_spherical_system"><a name="//apple_ref/cpp/Function/neurodiffeq.pde_spherical.solve_spherical_system"></a>
<code class="sig-prename descclassname">neurodiffeq.pde_spherical.</code><code class="sig-name descname">solve_spherical_system</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pde_system</span></em>, <em class="sig-param"><span class="n">conditions</span></em>, <em class="sig-param"><span class="n">r_min</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">r_max</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">nets</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">train_generator</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">shuffle</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">valid_generator</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">analytic_solutions</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">optimizer</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">criterion</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">batch_size</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">max_epochs</span><span class="o">=</span><span class="default_value">1000</span></em>, <em class="sig-param"><span class="n">monitor</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">return_internal</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">return_best</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">harmonics_fn</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.pde_spherical.solve_spherical_system" title="Permalink to this definition">¶</a></dt>
<dd><p>[DEPRECATED, use SphericalSolver class instead] Train a neural network to solve a PDE system with spherical inputs in 3D space</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pde_system</strong> (<em>callable</em>) – The PDEs ystem to solve. If the PDE is <span class="math notranslate nohighlight">\(F_i(u_1, u_2, ..., u_n, r,\theta, \phi) = 0\)</span> where <span class="math notranslate nohighlight">\(u_i\)</span> is the i-th dependent variable and <span class="math notranslate nohighlight">\(r\)</span>, <span class="math notranslate nohighlight">\(\theta\)</span> and <span class="math notranslate nohighlight">\(\phi\)</span> are the independent variables,
then <cite>pde_system</cite> should be a function that maps <span class="math notranslate nohighlight">\((u_1, u_2, ..., u_n, r, \theta, \phi)\)</span> to a list where the i-th entry is <span class="math notranslate nohighlight">\(F_i(u_1, u_2, ..., u_n, r, \theta, \phi)\)</span>.</p></li>
<li><p><strong>conditions</strong> (list[<cite>neurodiffeq.conditions.BaseCondition</cite>]) – The initial/boundary conditions. The ith entry of the conditions is the condition that <span class="math notranslate nohighlight">\(u_i\)</span> should satisfy.</p></li>
<li><p><strong>r_min</strong> (<em>float</em>) – radius for inner boundary; ignored if both generators are provided; optional</p></li>
<li><p><strong>r_max</strong> (<em>float</em>) – radius for outer boundary; ignored if both generators are provided; optional</p></li>
<li><p><strong>nets</strong> (list[<cite>torch.nn.Module</cite>], optionalnerate 3-D training points, default to None.) – The neural networks used to approximate the solution, defaults to None.</p></li>
<li><p><strong>train_generator</strong> (<cite>neurodiffeq.pde_spherical.BaseGenerator</cite>, optional) – The example generator to generate 3-D training points, default to None.</p></li>
<li><p><strong>valid_generator</strong> (<cite>neurodiffeq.pde_spherical.BaseGenerator</cite>, optional) – The example generator to generate 3-D validation points, default to None.</p></li>
<li><p><strong>shuffle</strong> (<em>bool</em><em>, </em><em>optional</em>) – deprecated and ignored; shuffling should be implemented in genrators</p></li>
<li><p><strong>analytic_solutions</strong> (<em>callable</em>) – analytic solution to the pde system, used for testing purposes; should map (rs, thetas, phis) to a list of [u_1, u_2, …, u_n]</p></li>
<li><p><strong>optimizer</strong> (<cite>torch.optim.Optimizer</cite>, optional) – The optimization method to use for training, defaults to None.</p></li>
<li><p><strong>criterion</strong> (<cite>torch.nn.modules.loss._Loss</cite>, optional) – The loss function to use for training, defaults to None.</p></li>
<li><p><strong>batch_size</strong> (<em>int</em><em>, </em><em>optional</em>) – The size of the mini-batch to use, defaults to 16.</p></li>
<li><p><strong>max_epochs</strong> (<em>int</em><em>, </em><em>optional</em>) – The maximum number of epochs to train, defaults to 1000.</p></li>
<li><p><strong>monitor</strong> (<cite>neurodiffeq.pde_spherical.MonitorSpherical</cite>, optional) – The monitor to check the status of neural network during training, defaults to None.</p></li>
<li><p><strong>return_internal</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to return the nets, conditions, training generator, validation generator, optimizer and loss function, defaults to False.</p></li>
<li><p><strong>return_best</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to return the nets that achieved the lowest validation loss, defaults to False.</p></li>
<li><p><strong>harmonics_fn</strong> (<em>callable</em>) – function basis (spherical harmonics for example) if solving coefficients of a function basis; used when returning solution</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The solution of the PDE. The history of training loss and validation loss.
Optionally, MSE against analytic solutions, the nets, conditions, training generator, validation generator, optimizer and loss function.
The solution is a function that has the signature <cite>solution(xs, ys, as_type)</cite>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tuple[<cite>neurodiffeq.pde_spherical.SolutionSpherical</cite>, dict]; or tuple[<cite>neurodiffeq.pde_spherical.SolutionSpherical</cite>, dict, dict]; or tuple[<cite>neurodiffeq.pde_spherical.SolutionSpherical</cite>, dict, dict, dict]</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function is deprecated, use a <cite>SphericalSolver</cite> instead</p>
</div>
</dd></dl>
</div>
<div class="section" id="module-neurodiffeq.temporal">
<span id="neurodiffeq-temporal"></span><h2><a name="//apple_ref/cpp/Module/neurodiffeq.temporal"></a><cite>neurodiffeq.temporal</cite><a class="headerlink" href="#module-neurodiffeq.temporal" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="neurodiffeq.temporal.Approximator"><a name="//apple_ref/cpp/Class/neurodiffeq.temporal.Approximator"></a>
<em class="property">class </em><code class="sig-prename descclassname">neurodiffeq.temporal.</code><code class="sig-name descname">Approximator</code><a class="headerlink" href="#neurodiffeq.temporal.Approximator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABC</span></code></p>
<p>The base class of approximators. An approximator is an approximation of the
differential equation’s solution. It knows the parameters in the neural network, 
and how to calculate the loss function and the metrics.</p>
</dd></dl>
<dl class="py class">
<dt id="neurodiffeq.temporal.BoundaryCondition"><a name="//apple_ref/cpp/Class/neurodiffeq.temporal.BoundaryCondition"></a>
<em class="property">class </em><code class="sig-prename descclassname">neurodiffeq.temporal.</code><code class="sig-name descname">BoundaryCondition</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">form</span></em>, <em class="sig-param"><span class="n">points_generator</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.temporal.BoundaryCondition" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A boundary condition. It is used to initialize <code class="docutils literal notranslate"><span class="pre">temporal.Approximator</span></code>s.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>form</strong> (<em>callable</em>) – The form of the boundary condition. For a 1D time-dependent problem, if the boundary condition demands that <span class="math notranslate nohighlight">\(B(u, x) = 0\)</span>, then <code class="docutils literal notranslate"><span class="pre">form</span></code> should be a function that maps <span class="math notranslate nohighlight">\(u, x, t\)</span> to <span class="math notranslate nohighlight">\(B(u, x)\)</span>. For a 2D steady-state problem, if the boundary condition demands that <span class="math notranslate nohighlight">\(B(u, x, y) = 0\)</span>, then <code class="docutils literal notranslate"><span class="pre">form</span></code> should be a function that maps <span class="math notranslate nohighlight">\(u, x, y\)</span> to <span class="math notranslate nohighlight">\(B(u, x, y)\)</span>. For a 2D steady-state system, if the boundary condition demands that <span class="math notranslate nohighlight">\(B(u_i, x, y) = 0\)</span>, then <cite>form</cite> should be a function that maps <span class="math notranslate nohighlight">\(u_1, u_2, ..., u_n, x, y\)</span> to <cite>B(u_i, x, y)</cite>. For 2D time-dependent problem, if the boundary condition demands that <span class="math notranslate nohighlight">\(B(u, x, y) = 0\)</span>, then <cite>form</cite> should be a function that maps <span class="math notranslate nohighlight">\(u, x, y, t\)</span> to <cite>B(u_i, x, y)</cite>. Basically the function signature of <code class="docutils literal notranslate"><span class="pre">form</span></code> should be the same as the <code class="docutils literal notranslate"><span class="pre">pde</span></code> function of the given <code class="docutils literal notranslate"><span class="pre">temporal.Approximator</span></code>.</p></li>
<li><p><strong>points_generator</strong> – A generator that generates points on the boundary.
It can be a <cite>temporal.generator_1dspatial</cite>, <cite>temporal.generator_2dspatial_segment</cite>,
or a generator written by user.</p></li>
</ul>
</dd>
</dl>
</dd></dl>
<dl class="py class">
<dt id="neurodiffeq.temporal.FirstOrderInitialCondition"><a name="//apple_ref/cpp/Class/neurodiffeq.temporal.FirstOrderInitialCondition"></a>
<em class="property">class </em><code class="sig-prename descclassname">neurodiffeq.temporal.</code><code class="sig-name descname">FirstOrderInitialCondition</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">u0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.temporal.FirstOrderInitialCondition" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A first order initial condition. It is used to initialize <code class="docutils literal notranslate"><span class="pre">temporal.Approximator</span></code>s.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>u0</strong> (<em>function</em>) – A function representing the initial condition. If we are solving for
is <span class="math notranslate nohighlight">\(u\)</span>, then <cite>u0</cite> is <span class="math notranslate nohighlight">\(u\bigg|_{t=0}\)</span>. The input of the function
dependes on where it is used. If it is used as the input for
<cite>temporal.SingleNetworkApproximator1DSpatialTemporal</cite>, then <cite>u0</cite> should map
<span class="math notranslate nohighlight">\(x\)</span> to <span class="math notranslate nohighlight">\(u(x, t)\bigg|_{t = 0}\)</span>. If it is used as the input for
<cite>temporal.SingleNetworkApproximator2DSpatialTemporal</cite>, then <cite>u0</cite> should map
<span class="math notranslate nohighlight">\((x, y)\)</span> to <span class="math notranslate nohighlight">\(u(x, y, t)\bigg|_{t = 0}\)</span>.</p>
</dd>
</dl>
</dd></dl>
<dl class="py class">
<dt id="neurodiffeq.temporal.Monitor1DSpatialTemporal"><a name="//apple_ref/cpp/Class/neurodiffeq.temporal.Monitor1DSpatialTemporal"></a>
<em class="property">class </em><code class="sig-prename descclassname">neurodiffeq.temporal.</code><code class="sig-name descname">Monitor1DSpatialTemporal</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">check_on_x</span></em>, <em class="sig-param"><span class="n">check_on_t</span></em>, <em class="sig-param"><span class="n">check_every</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.temporal.Monitor1DSpatialTemporal" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A monitor for 1D time-dependent problems.</p>
</dd></dl>
<dl class="py class">
<dt id="neurodiffeq.temporal.Monitor2DSpatial"><a name="//apple_ref/cpp/Class/neurodiffeq.temporal.Monitor2DSpatial"></a>
<em class="property">class </em><code class="sig-prename descclassname">neurodiffeq.temporal.</code><code class="sig-name descname">Monitor2DSpatial</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">check_on_x</span></em>, <em class="sig-param"><span class="n">check_on_y</span></em>, <em class="sig-param"><span class="n">check_every</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.temporal.Monitor2DSpatial" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A Monitor for 2D steady-state problems</p>
</dd></dl>
<dl class="py class">
<dt id="neurodiffeq.temporal.Monitor2DSpatialTemporal"><a name="//apple_ref/cpp/Class/neurodiffeq.temporal.Monitor2DSpatialTemporal"></a>
<em class="property">class </em><code class="sig-prename descclassname">neurodiffeq.temporal.</code><code class="sig-name descname">Monitor2DSpatialTemporal</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">check_on_x</span></em>, <em class="sig-param"><span class="n">check_on_y</span></em>, <em class="sig-param"><span class="n">check_on_t</span></em>, <em class="sig-param"><span class="n">check_every</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.temporal.Monitor2DSpatialTemporal" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A monitor for 2D time-dependent problems.</p>
</dd></dl>
<dl class="py class">
<dt id="neurodiffeq.temporal.MonitorMinimal"><a name="//apple_ref/cpp/Class/neurodiffeq.temporal.MonitorMinimal"></a>
<em class="property">class </em><code class="sig-prename descclassname">neurodiffeq.temporal.</code><code class="sig-name descname">MonitorMinimal</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">check_every</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.temporal.MonitorMinimal" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A monitor that shows the loss function and custom metrics.</p>
</dd></dl>
<dl class="py class">
<dt id="neurodiffeq.temporal.SecondOrderInitialCondition"><a name="//apple_ref/cpp/Class/neurodiffeq.temporal.SecondOrderInitialCondition"></a>
<em class="property">class </em><code class="sig-prename descclassname">neurodiffeq.temporal.</code><code class="sig-name descname">SecondOrderInitialCondition</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">u0</span></em>, <em class="sig-param"><span class="n">u0dot</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.temporal.SecondOrderInitialCondition" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A second order initial condition. It is used to initialize <code class="docutils literal notranslate"><span class="pre">temporal.Approximator</span></code>s.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>u0</strong> (<em>function</em>) – A function representing the initial condition. If we are solving for
is <span class="math notranslate nohighlight">\(u\)</span>, then <code class="docutils literal notranslate"><span class="pre">u0</span></code> is <span class="math notranslate nohighlight">\(u\bigg|_{t=0}\)</span>. The input of the function
dependes on where it is used. If it is used as the input for
<code class="docutils literal notranslate"><span class="pre">temporal.SingleNetworkApproximator1DSpatialTemporal</span></code>, then <code class="docutils literal notranslate"><span class="pre">u0</span></code> should map
<span class="math notranslate nohighlight">\(x\)</span> to <span class="math notranslate nohighlight">\(u(x, t)\bigg|_{t = 0}\)</span>. If it is used as the input for
<code class="docutils literal notranslate"><span class="pre">temporal.SingleNetworkApproximator2DSpatialTemporal</span></code>, then <code class="docutils literal notranslate"><span class="pre">u0</span></code> should map
<span class="math notranslate nohighlight">\((x, y)\)</span> to <span class="math notranslate nohighlight">\(u(x, y, t)\bigg|_{t = 0}\)</span>.</p></li>
<li><p><strong>u0dot</strong> (<em>function</em>) – A function representing the initial derivative w.r.t. time. If we are solving for
is :math:<code class="docutils literal notranslate"><span class="pre">u</span></code>, then <code class="docutils literal notranslate"><span class="pre">u0dot</span></code> is <span class="math notranslate nohighlight">\(\dfrac{\partial u}{\partial t}\bigg|_{t=0}\)</span>.
The input of the function
depends on where it is used. If it is used as the input for
<code class="docutils literal notranslate"><span class="pre">temporal.SingleNetworkApproximator1DSpatialTemporal</span></code>, then <code class="docutils literal notranslate"><span class="pre">u0</span></code> should map
<span class="math notranslate nohighlight">\(x\)</span> to <span class="math notranslate nohighlight">\(\dfrac{\partial u}{\partial t}\bigg|_{t = 0}\)</span>. If it is used as the input for
<cite>temporal.SingleNetworkApproximator2DSpatialTemporal</cite>, then <code class="docutils literal notranslate"><span class="pre">u0</span></code> should map
<span class="math notranslate nohighlight">\((x, y)\)</span> to <span class="math notranslate nohighlight">\(\dfrac{\partial u}{\partial t}\bigg|_{t = 0}\)</span>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>
<dl class="py class">
<dt id="neurodiffeq.temporal.SingleNetworkApproximator1DSpatialTemporal"><a name="//apple_ref/cpp/Class/neurodiffeq.temporal.SingleNetworkApproximator1DSpatialTemporal"></a>
<em class="property">class </em><code class="sig-prename descclassname">neurodiffeq.temporal.</code><code class="sig-name descname">SingleNetworkApproximator1DSpatialTemporal</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">single_network</span></em>, <em class="sig-param"><span class="n">pde</span></em>, <em class="sig-param"><span class="n">initial_condition</span></em>, <em class="sig-param"><span class="n">boundary_conditions</span></em>, <em class="sig-param"><span class="n">boundary_strictness</span><span class="o">=</span><span class="default_value">1.0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.temporal.SingleNetworkApproximator1DSpatialTemporal" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#neurodiffeq.temporal.Approximator" title="neurodiffeq.temporal.Approximator"><code class="xref py py-class docutils literal notranslate"><span class="pre">neurodiffeq.temporal.Approximator</span></code></a></p>
<p>An approximator to approximate the solution of a 1D time-dependent problem.
The boundary condition will be enforced by a regularization term in the loss function
and the initial condition will be enforced by transforming the output of the
neural network.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>single_network</strong> (<cite>torch.nn.Module</cite>) – A neural network with 2 input nodes (x, t) and 1 output node</p></li>
<li><p><strong>pde</strong> (<em>function</em>) – The PDE to solve. If the PDE is <span class="math notranslate nohighlight">\(F(u, x, t) = 0\)</span> then <cite>pde</cite> 
should be a function that maps <span class="math notranslate nohighlight">\((u, x, t)\)</span> to <span class="math notranslate nohighlight">\(F(u, x, t)\)</span>.</p></li>
<li><p><strong>initial_condition</strong> (<cite>temporal.FirstOrderInitialCondition</cite>) – A first order initial condition</p></li>
<li><p><strong>boundary_conditions</strong> (list[<cite>temporal.BoundaryCondition</cite>]) – A list of boundary conditions</p></li>
<li><p><strong>boundary_strictness</strong> (<em>float</em>) – The regularization parameter, defaults to 1.
a larger regularization parameter enforces the boundary conditions more strictly.</p></li>
</ul>
</dd>
</dl>
</dd></dl>
<dl class="py class">
<dt id="neurodiffeq.temporal.SingleNetworkApproximator2DSpatial"><a name="//apple_ref/cpp/Class/neurodiffeq.temporal.SingleNetworkApproximator2DSpatial"></a>
<em class="property">class </em><code class="sig-prename descclassname">neurodiffeq.temporal.</code><code class="sig-name descname">SingleNetworkApproximator2DSpatial</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">single_network</span></em>, <em class="sig-param"><span class="n">pde</span></em>, <em class="sig-param"><span class="n">boundary_conditions</span></em>, <em class="sig-param"><span class="n">boundary_strictness</span><span class="o">=</span><span class="default_value">1.0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.temporal.SingleNetworkApproximator2DSpatial" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#neurodiffeq.temporal.Approximator" title="neurodiffeq.temporal.Approximator"><code class="xref py py-class docutils literal notranslate"><span class="pre">neurodiffeq.temporal.Approximator</span></code></a></p>
<p>An approximator to approximate the solution of a 2D steady-state problem.
The boundary condition will be enforced by a regularization term in the loss function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>single_network</strong> (<cite>torch.nn.Module</cite>) – A neural network with 2 input nodes (x, y) and 1 output node</p></li>
<li><p><strong>pde</strong> (<em>function</em>) – The PDE to solve. If the PDE is <span class="math notranslate nohighlight">\(F(u, x, y) = 0\)</span> then <cite>pde</cite> 
should be a function that maps <span class="math notranslate nohighlight">\((u, x, y)\)</span> to <span class="math notranslate nohighlight">\(F(u, x, y)\)</span>.</p></li>
<li><p><strong>boundary_conditions</strong> (list[<cite>temporal.BoundaryCondition</cite>]) – A list of boundary conditions</p></li>
<li><p><strong>boundary_strictness</strong> (<em>float</em>) – The regularization parameter, defaults to 1.
a larger regularization parameter enforces the boundary conditions more strictly.</p></li>
</ul>
</dd>
</dl>
</dd></dl>
<dl class="py class">
<dt id="neurodiffeq.temporal.SingleNetworkApproximator2DSpatialSystem"><a name="//apple_ref/cpp/Class/neurodiffeq.temporal.SingleNetworkApproximator2DSpatialSystem"></a>
<em class="property">class </em><code class="sig-prename descclassname">neurodiffeq.temporal.</code><code class="sig-name descname">SingleNetworkApproximator2DSpatialSystem</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">single_network</span></em>, <em class="sig-param"><span class="n">pde</span></em>, <em class="sig-param"><span class="n">boundary_conditions</span></em>, <em class="sig-param"><span class="n">boundary_strictness</span><span class="o">=</span><span class="default_value">1.0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.temporal.SingleNetworkApproximator2DSpatialSystem" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#neurodiffeq.temporal.Approximator" title="neurodiffeq.temporal.Approximator"><code class="xref py py-class docutils literal notranslate"><span class="pre">neurodiffeq.temporal.Approximator</span></code></a></p>
<p>An approximator to approximate the solution of a 2D steady-state differential equation system.
The boundary condition will be enforced by a regularization term in the loss function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>single_network</strong> (<cite>torch.nn.Module</cite>) – A neural network with 2 input nodes (x, y) and n output node (n is the number of
dependent variables in the differential equation system)</p></li>
<li><p><strong>pde</strong> (<em>function</em>) – The PDE system to solve. If the PDE is <span class="math notranslate nohighlight">\(F_i(u_1, u_2, ..., u_n, x, y) = 0\)</span>
where <span class="math notranslate nohighlight">\(u_i\)</span> is the i-th dependent variable,
then <cite>pde</cite> should be a function that maps <span class="math notranslate nohighlight">\((u_1, u_2, ..., u_n, x, y)\)</span> to
a list where the i-th entry is <span class="math notranslate nohighlight">\(F_i(u_1, u_2, ..., u_n, x, y)\)</span>.</p></li>
<li><p><strong>boundary_conditions</strong> (list[<cite>temporal.BoundaryCondition</cite>]) – A list of boundary conditions</p></li>
<li><p><strong>boundary_strictness</strong> (<em>float</em>) – The regularization parameter, defaults to 1.
a larger regularization parameter enforces the boundary conditions more strictly.</p></li>
</ul>
</dd>
</dl>
</dd></dl>
<dl class="py class">
<dt id="neurodiffeq.temporal.SingleNetworkApproximator2DSpatialTemporal"><a name="//apple_ref/cpp/Class/neurodiffeq.temporal.SingleNetworkApproximator2DSpatialTemporal"></a>
<em class="property">class </em><code class="sig-prename descclassname">neurodiffeq.temporal.</code><code class="sig-name descname">SingleNetworkApproximator2DSpatialTemporal</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">single_network</span></em>, <em class="sig-param"><span class="n">pde</span></em>, <em class="sig-param"><span class="n">initial_condition</span></em>, <em class="sig-param"><span class="n">boundary_conditions</span></em>, <em class="sig-param"><span class="n">boundary_strictness</span><span class="o">=</span><span class="default_value">1.0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.temporal.SingleNetworkApproximator2DSpatialTemporal" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#neurodiffeq.temporal.Approximator" title="neurodiffeq.temporal.Approximator"><code class="xref py py-class docutils literal notranslate"><span class="pre">neurodiffeq.temporal.Approximator</span></code></a></p>
<p>An approximator to approximate the solution of a 2D time-dependent problem.
The boundary condition will be enforced by a regularization term in the loss function
and the initial condition will be enforced by transforming the output of the
neural network.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>single_network</strong> (<cite>torch.nn.Module</cite>) – A neural network with 3 input nodes (x, y, t) and 1 output node.</p></li>
<li><p><strong>pde</strong> (<em>function</em>) – The PDE system to solve. If the PDE is <span class="math notranslate nohighlight">\(F(u, x, y, t) = 0\)</span>
then <cite>pde</cite> should be a function that maps <span class="math notranslate nohighlight">\((u, x, y, t)\)</span> to <span class="math notranslate nohighlight">\(F(u, x, y, t)\)</span>.</p></li>
<li><p><strong>initial_condition</strong> (<cite>temporal.FirstOrderInitialCondition</cite> or <cite>temporal.SecondOrderInitialCondition</cite>) – A first order initial condition</p></li>
<li><p><strong>boundary_conditions</strong> (list[<cite>temporal.BoundaryCondition</cite>]) – A list of boundary conditions</p></li>
<li><p><strong>boundary_strictness</strong> (<em>float</em>) – The regularization parameter, defaults to 1.
a larger regularization parameter enforces the boundary conditions more strictly.</p></li>
</ul>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt id="neurodiffeq.temporal.generator_1dspatial"><a name="//apple_ref/cpp/Function/neurodiffeq.temporal.generator_1dspatial"></a>
<code class="sig-prename descclassname">neurodiffeq.temporal.</code><code class="sig-name descname">generator_1dspatial</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">size</span></em>, <em class="sig-param"><span class="n">x_min</span></em>, <em class="sig-param"><span class="n">x_max</span></em>, <em class="sig-param"><span class="n">random</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.temporal.generator_1dspatial" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a generator that generates 1D points range from x_min to x_max</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>size</strong> (<em>int</em>) – number of points to generated when <cite>__next__</cite> is invoked</p></li>
<li><p><strong>x_min</strong> (<em>float</em>) – Lower bound of x</p></li>
<li><p><strong>x_max</strong> (<em>float</em>) – Upper bound of x</p></li>
<li><p><strong>random</strong> (<em>bool</em>) – If set to False, then return eqally spaced points range from
x_min to x_max. If set to True then generate points randomly. Defaults to True</p></li>
</ul>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt id="neurodiffeq.temporal.generator_2dspatial_rectangle"><a name="//apple_ref/cpp/Function/neurodiffeq.temporal.generator_2dspatial_rectangle"></a>
<code class="sig-prename descclassname">neurodiffeq.temporal.</code><code class="sig-name descname">generator_2dspatial_rectangle</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">size</span></em>, <em class="sig-param"><span class="n">x_min</span></em>, <em class="sig-param"><span class="n">x_max</span></em>, <em class="sig-param"><span class="n">y_min</span></em>, <em class="sig-param"><span class="n">y_max</span></em>, <em class="sig-param"><span class="n">random</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.temporal.generator_2dspatial_rectangle" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a generator that generates 2D points in a rectangle.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>size</strong> (<em>int</em>) – number of points to generated when <cite>__next__</cite> is invoked</p></li>
<li><p><strong>start</strong> (<em>tuple</em><em>[</em><em>float</em><em>, </em><em>float</em><em>]</em>) – the starting point of the line segment</p></li>
<li><p><strong>end</strong> (<em>tuple</em><em>[</em><em>float</em><em>, </em><em>float</em><em>]</em>) – the ending point of the line segment</p></li>
<li><p><strong>random</strong> (<em>bool</em>) – If set to False, then return eqally spaced points range from
<cite>start</cite> to <cite>end</cite>. If set to Rrue then generate points randomly. Defaults to True.</p></li>
</ul>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt id="neurodiffeq.temporal.generator_2dspatial_segment"><a name="//apple_ref/cpp/Function/neurodiffeq.temporal.generator_2dspatial_segment"></a>
<code class="sig-prename descclassname">neurodiffeq.temporal.</code><code class="sig-name descname">generator_2dspatial_segment</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">size</span></em>, <em class="sig-param"><span class="n">start</span></em>, <em class="sig-param"><span class="n">end</span></em>, <em class="sig-param"><span class="n">random</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.temporal.generator_2dspatial_segment" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a generator that generates 2D points in a line segment.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>size</strong> (<em>int</em>) – number of points to generated when <cite>__next__</cite> is invoked</p></li>
<li><p><strong>x_min</strong> (<em>float</em>) – Lower bound of x</p></li>
<li><p><strong>x_max</strong> (<em>float</em>) – Upper bound of x</p></li>
<li><p><strong>y_min</strong> (<em>float</em>) – Lower bound of y</p></li>
<li><p><strong>y_max</strong> (<em>float</em>) – Upper bound of y</p></li>
<li><p><strong>random</strong> (<em>bool</em>) – If set to False, then return a grid where the points are eqally
spaced in the x and y dimension. If set to True then generate points randomly. 
Defaults to True.</p></li>
</ul>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt id="neurodiffeq.temporal.generator_temporal"><a name="//apple_ref/cpp/Function/neurodiffeq.temporal.generator_temporal"></a>
<code class="sig-prename descclassname">neurodiffeq.temporal.</code><code class="sig-name descname">generator_temporal</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">size</span></em>, <em class="sig-param"><span class="n">t_min</span></em>, <em class="sig-param"><span class="n">t_max</span></em>, <em class="sig-param"><span class="n">random</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.temporal.generator_temporal" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a generator that generates 1D points range from t_min to t_max</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>size</strong> (<em>int</em>) – number of points to generated when <cite>__next__</cite> is invoked</p></li>
<li><p><strong>t_min</strong> (<em>float</em>) – Lower bound of t</p></li>
<li><p><strong>t_max</strong> (<em>float</em>) – Upper bound of t</p></li>
<li><p><strong>random</strong> (<em>bool</em>) – If set to False, then return eqally spaced points range from
t_min to t_max. If set to True then generate points randomly. Defaults to True</p></li>
</ul>
</dd>
</dl>
</dd></dl>
</div>
<div class="section" id="module-neurodiffeq.function_basis">
<span id="neurodiffeq-function-basis"></span><h2><a name="//apple_ref/cpp/Module/neurodiffeq.function_basis"></a><cite>neurodiffeq.function_basis</cite><a class="headerlink" href="#module-neurodiffeq.function_basis" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="neurodiffeq.function_basis.BasisOperator"><a name="//apple_ref/cpp/Class/neurodiffeq.function_basis.BasisOperator"></a>
<em class="property">class </em><code class="sig-prename descclassname">neurodiffeq.function_basis.</code><code class="sig-name descname">BasisOperator</code><a class="headerlink" href="#neurodiffeq.function_basis.BasisOperator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABC</span></code></p>
</dd></dl>
<dl class="py class">
<dt id="neurodiffeq.function_basis.CustomBasis"><a name="//apple_ref/cpp/Class/neurodiffeq.function_basis.CustomBasis"></a>
<em class="property">class </em><code class="sig-prename descclassname">neurodiffeq.function_basis.</code><code class="sig-name descname">CustomBasis</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fns</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.function_basis.CustomBasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#neurodiffeq.function_basis.FunctionBasis" title="neurodiffeq.function_basis.FunctionBasis"><code class="xref py py-class docutils literal notranslate"><span class="pre">neurodiffeq.function_basis.FunctionBasis</span></code></a></p>
</dd></dl>
<dl class="py class">
<dt id="neurodiffeq.function_basis.FourierLaplacian"><a name="//apple_ref/cpp/Class/neurodiffeq.function_basis.FourierLaplacian"></a>
<em class="property">class </em><code class="sig-prename descclassname">neurodiffeq.function_basis.</code><code class="sig-name descname">FourierLaplacian</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">max_degree</span><span class="o">=</span><span class="default_value">12</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.function_basis.FourierLaplacian" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#neurodiffeq.function_basis.BasisOperator" title="neurodiffeq.function_basis.BasisOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">neurodiffeq.function_basis.BasisOperator</span></code></a></p>
<p>A Laplacian operator (in polar coordinates) acting on
<span class="math notranslate nohighlight">\(\displaystyle\sum_{i} R_i(r)F(\phi)\)</span> where <span class="math notranslate nohighlight">\(F\)</span> is a Fourier component</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>max_degree</strong> (<em>int</em>) – highest degree for the fourier series</p>
</dd>
</dl>
</dd></dl>
<dl class="py class">
<dt id="neurodiffeq.function_basis.FunctionBasis"><a name="//apple_ref/cpp/Class/neurodiffeq.function_basis.FunctionBasis"></a>
<em class="property">class </em><code class="sig-prename descclassname">neurodiffeq.function_basis.</code><code class="sig-name descname">FunctionBasis</code><a class="headerlink" href="#neurodiffeq.function_basis.FunctionBasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABC</span></code></p>
</dd></dl>
<dl class="py class">
<dt id="neurodiffeq.function_basis.HarmonicsLaplacian"><a name="//apple_ref/cpp/Class/neurodiffeq.function_basis.HarmonicsLaplacian"></a>
<em class="property">class </em><code class="sig-prename descclassname">neurodiffeq.function_basis.</code><code class="sig-name descname">HarmonicsLaplacian</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">max_degree</span><span class="o">=</span><span class="default_value">4</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.function_basis.HarmonicsLaplacian" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#neurodiffeq.function_basis.BasisOperator" title="neurodiffeq.function_basis.BasisOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">neurodiffeq.function_basis.BasisOperator</span></code></a></p>
<p>Laplacian of spherical harmonics can be reduced in the following way. Using this method,
we can avoid the <span class="math notranslate nohighlight">\(\displaystyle \frac{1}{\sin \theta}\)</span> singularity</p>
<p><span class="math notranslate nohighlight">\(\begin{aligned}
&amp;\nabla^{2} R_{l, m}(r) Y_{l,m}(\theta, \phi)\\
&amp;=\left(\nabla_{r}^{2}+\nabla_{\theta}^{2}+\nabla_{\phi}^{2}\right)\left(R_{l, m}(r) Y_{l, m}(\theta, \phi)\right)\\
&amp;=Y_{l, m} \nabla_{r}^{2} R_{l, m}+R_{l, m}\left(\left(\nabla_{\theta}^{2}+\nabla_{\phi}^{2}\right) Y_{l, m}\right)\\
&amp;=Y_{l, m} \nabla_{r}^{2} R_{l, m}+R_{l, m} \frac{-l(l+1)}{r^{2}} Y_{l, m}\\
&amp;=Y_{l, m}\left(\nabla_{r}^{2} R_{l, m}+\frac{-l(l+1)}{r^{2}} R_{l, m}\right)
\end{aligned}\)</span></p>
</dd></dl>
<dl class="py class">
<dt id="neurodiffeq.function_basis.LegendreBasis"><a name="//apple_ref/cpp/Class/neurodiffeq.function_basis.LegendreBasis"></a>
<em class="property">class </em><code class="sig-prename descclassname">neurodiffeq.function_basis.</code><code class="sig-name descname">LegendreBasis</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">max_degree</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.function_basis.LegendreBasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#neurodiffeq.function_basis.FunctionBasis" title="neurodiffeq.function_basis.FunctionBasis"><code class="xref py py-class docutils literal notranslate"><span class="pre">neurodiffeq.function_basis.FunctionBasis</span></code></a></p>
</dd></dl>
<dl class="py class">
<dt id="neurodiffeq.function_basis.RealFourierSeries"><a name="//apple_ref/cpp/Class/neurodiffeq.function_basis.RealFourierSeries"></a>
<em class="property">class </em><code class="sig-prename descclassname">neurodiffeq.function_basis.</code><code class="sig-name descname">RealFourierSeries</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">max_degree</span><span class="o">=</span><span class="default_value">12</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.function_basis.RealFourierSeries" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#neurodiffeq.function_basis.FunctionBasis" title="neurodiffeq.function_basis.FunctionBasis"><code class="xref py py-class docutils literal notranslate"><span class="pre">neurodiffeq.function_basis.FunctionBasis</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>max_degree</strong> (<em>int</em>) – highest degree for the fourier series</p>
</dd>
</dl>
</dd></dl>
<dl class="py class">
<dt id="neurodiffeq.function_basis.RealSphericalHarmonics"><a name="//apple_ref/cpp/Class/neurodiffeq.function_basis.RealSphericalHarmonics"></a>
<em class="property">class </em><code class="sig-prename descclassname">neurodiffeq.function_basis.</code><code class="sig-name descname">RealSphericalHarmonics</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">max_degree</span><span class="o">=</span><span class="default_value">4</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.function_basis.RealSphericalHarmonics" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#neurodiffeq.function_basis.FunctionBasis" title="neurodiffeq.function_basis.FunctionBasis"><code class="xref py py-class docutils literal notranslate"><span class="pre">neurodiffeq.function_basis.FunctionBasis</span></code></a></p>
<p>Spherical harmonics as a function basis</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>max_degree</strong> (<em>int</em>) – highest degree (currently only supports l&lt;=4) for the spherical harmonics_fn</p>
</dd>
</dl>
</dd></dl>
<dl class="py class">
<dt id="neurodiffeq.function_basis.ZonalSphericalHarmonics"><a name="//apple_ref/cpp/Class/neurodiffeq.function_basis.ZonalSphericalHarmonics"></a>
<em class="property">class </em><code class="sig-prename descclassname">neurodiffeq.function_basis.</code><code class="sig-name descname">ZonalSphericalHarmonics</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">max_degree</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">degrees</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.function_basis.ZonalSphericalHarmonics" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#neurodiffeq.function_basis.FunctionBasis" title="neurodiffeq.function_basis.FunctionBasis"><code class="xref py py-class docutils literal notranslate"><span class="pre">neurodiffeq.function_basis.FunctionBasis</span></code></a></p>
<p>Zonal harmonics (spherical harmonics with order=0)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>max_degree</strong> (<em>int</em>) – highest degrees to be included; degrees will contain {0, 1, …, max_degree}; ignored if <cite>degrees</cite> is passed</p></li>
<li><p><strong>degrees</strong> (<em>list</em><em>[</em><em>int</em><em>]</em>) – a list of degrees to be used, must be nonnegative and unique; if passed, <cite>max_degrees</cite> will be ignored</p></li>
</ul>
</dd>
</dl>
</dd></dl>
<dl class="py class">
<dt id="neurodiffeq.function_basis.ZonalSphericalHarmonicsLaplacian"><a name="//apple_ref/cpp/Class/neurodiffeq.function_basis.ZonalSphericalHarmonicsLaplacian"></a>
<em class="property">class </em><code class="sig-prename descclassname">neurodiffeq.function_basis.</code><code class="sig-name descname">ZonalSphericalHarmonicsLaplacian</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">max_degree</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">degrees</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.function_basis.ZonalSphericalHarmonicsLaplacian" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#neurodiffeq.function_basis.BasisOperator" title="neurodiffeq.function_basis.BasisOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">neurodiffeq.function_basis.BasisOperator</span></code></a></p>
<p>Laplacian operator acting on coefficients of zonal harmonics (spherical harmonics with order=0)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>max_degree</strong> (<em>int</em>) – highest degrees to be included; degrees will contain {0, 1, …, max_degree}; ignored if <cite>degrees</cite> is passed</p></li>
<li><p><strong>degrees</strong> (<em>list</em><em>[</em><em>int</em><em>]</em>) – a list of degrees to be used, must be nonnegative and unique; if passed, <cite>max_degrees</cite> will be ignored</p></li>
</ul>
</dd>
</dl>
</dd></dl>
</div>
<div class="section" id="module-neurodiffeq.generators">
<span id="neurodiffeq-generators"></span><h2><a name="//apple_ref/cpp/Module/neurodiffeq.generators"></a><cite>neurodiffeq.generators</cite><a class="headerlink" href="#module-neurodiffeq.generators" title="Permalink to this headline">¶</a></h2>
<p>This module contains atomic generator classes and useful tools to construct complex generators out of atomic ones</p>
<dl class="py class">
<dt id="neurodiffeq.generators.BaseGenerator"><a name="//apple_ref/cpp/Class/neurodiffeq.generators.BaseGenerator"></a>
<em class="property">class </em><code class="sig-prename descclassname">neurodiffeq.generators.</code><code class="sig-name descname">BaseGenerator</code><a class="headerlink" href="#neurodiffeq.generators.BaseGenerator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Base class for all generators; Children classes must implement a <cite>.get_examples</cite> method and a <cite>.size</cite> field</p>
</dd></dl>
<dl class="py class">
<dt id="neurodiffeq.generators.BatchGenerator"><a name="//apple_ref/cpp/Class/neurodiffeq.generators.BatchGenerator"></a>
<em class="property">class </em><code class="sig-prename descclassname">neurodiffeq.generators.</code><code class="sig-name descname">BatchGenerator</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">generator</span></em>, <em class="sig-param"><span class="n">batch_size</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.generators.BatchGenerator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#neurodiffeq.generators.BaseGenerator" title="neurodiffeq.generators.BaseGenerator"><code class="xref py py-class docutils literal notranslate"><span class="pre">neurodiffeq.generators.BaseGenerator</span></code></a></p>
<p>A generator which caches samples and returns a single batch of the samples at a time</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>generator</strong> (<a class="reference internal" href="#neurodiffeq.generators.BaseGenerator" title="neurodiffeq.generators.BaseGenerator"><em>BaseGenerator</em></a>) – a generator used for getting (cached) examples</p></li>
<li><p><strong>batch_size</strong> (<em>int</em>) – number of batches to be returned; can be larger than size of  <cite>generator</cite>, but inefficient if so</p></li>
</ul>
</dd>
</dl>
</dd></dl>
<dl class="py class">
<dt id="neurodiffeq.generators.ConcatGenerator"><a name="//apple_ref/cpp/Class/neurodiffeq.generators.ConcatGenerator"></a>
<em class="property">class </em><code class="sig-prename descclassname">neurodiffeq.generators.</code><code class="sig-name descname">ConcatGenerator</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">generators</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.generators.ConcatGenerator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#neurodiffeq.generators.BaseGenerator" title="neurodiffeq.generators.BaseGenerator"><code class="xref py py-class docutils literal notranslate"><span class="pre">neurodiffeq.generators.BaseGenerator</span></code></a></p>
<dl class="simple">
<dt>An concatenated generator for sampling points, whose <cite>get_examples</cite> method returns the concatenated vector of the samples returned by its sub-generators.</dt><dd><p>Not to be confused with EnsembleGenerator which returns all the samples of its sub-generators</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>generators</strong> (<em>a sequence of sub-generators</em><em>, </em><em>must have a .size field and a .get_examples</em><em>(</em><em>) </em><em>method</em>) – a sequence of sub-generators, must have a .size field and a .get_examples() method</p>
</dd>
</dl>
</dd></dl>
<dl class="py class">
<dt id="neurodiffeq.generators.EnsembleGenerator"><a name="//apple_ref/cpp/Class/neurodiffeq.generators.EnsembleGenerator"></a>
<em class="property">class </em><code class="sig-prename descclassname">neurodiffeq.generators.</code><code class="sig-name descname">EnsembleGenerator</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">generators</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.generators.EnsembleGenerator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#neurodiffeq.generators.BaseGenerator" title="neurodiffeq.generators.BaseGenerator"><code class="xref py py-class docutils literal notranslate"><span class="pre">neurodiffeq.generators.BaseGenerator</span></code></a></p>
<dl class="simple">
<dt>An ensemble generator for sampling points, whose <cite>get_examples</cite> method returns all the samples of its sub-generators;</dt><dd><p>Not to be confused with ConcatGenerator which returns the concatenated vector of samples returned by its sub-generators.
All sub-generator must return vectors of the same shape; yet the number of vectors for each sub-generator can be different</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>*generators</strong> (<em>a sequence of sub-generators</em><em>, </em><em>must have a .size field and a .get_examples</em><em>(</em><em>) </em><em>method</em>) – a sequence of sub-generators, must have a .size field and a .get_examples() method</p>
</dd>
</dl>
</dd></dl>
<dl class="py class">
<dt id="neurodiffeq.generators.FilterGenerator"><a name="//apple_ref/cpp/Class/neurodiffeq.generators.FilterGenerator"></a>
<em class="property">class </em><code class="sig-prename descclassname">neurodiffeq.generators.</code><code class="sig-name descname">FilterGenerator</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">generator</span></em>, <em class="sig-param"><span class="n">filter_fn</span></em>, <em class="sig-param"><span class="n">size</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">update_size</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.generators.FilterGenerator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#neurodiffeq.generators.BaseGenerator" title="neurodiffeq.generators.BaseGenerator"><code class="xref py py-class docutils literal notranslate"><span class="pre">neurodiffeq.generators.BaseGenerator</span></code></a></p>
<p>A generator which applies some filtering before samples are returned</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>generator</strong> (<a class="reference internal" href="#neurodiffeq.generators.BaseGenerator" title="neurodiffeq.generators.BaseGenerator"><em>BaseGenerator</em></a>) – a generator used to generate samples to be filtered</p></li>
<li><p><strong>filter_fn</strong> (<em>callable</em>) – a filter to be applied on the sample vectors; maps a list of tensors to a mask tensor</p></li>
<li><p><strong>size</strong> (<em>int</em>) – size to be used for <cite>self.size</cite>; if not given, this attribute is initialized to the size of <cite>generator</cite></p></li>
<li><p><strong>update_size</strong> (<em>bool</em>) – whether or not to update <cite>.size</cite> after each call of <cite>self.get_examples</cite>; defaults to True</p></li>
</ul>
</dd>
</dl>
</dd></dl>
<dl class="py class">
<dt id="neurodiffeq.generators.Generator1D"><a name="//apple_ref/cpp/Class/neurodiffeq.generators.Generator1D"></a>
<em class="property">class </em><code class="sig-prename descclassname">neurodiffeq.generators.</code><code class="sig-name descname">Generator1D</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">size</span></em>, <em class="sig-param"><span class="n">t_min</span><span class="o">=</span><span class="default_value">0.0</span></em>, <em class="sig-param"><span class="n">t_max</span><span class="o">=</span><span class="default_value">1.0</span></em>, <em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">'uniform'</span></em>, <em class="sig-param"><span class="n">noise_std</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.generators.Generator1D" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#neurodiffeq.generators.BaseGenerator" title="neurodiffeq.generators.BaseGenerator"><code class="xref py py-class docutils literal notranslate"><span class="pre">neurodiffeq.generators.BaseGenerator</span></code></a></p>
<p>An example generator for generating 1-D training points.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>size</strong> (<em>int</em>) – The number of points to generate each time <cite>get_examples</cite> is called.</p></li>
<li><p><strong>t_min</strong> (<em>float</em><em>, </em><em>optional</em>) – The lower bound of the 1-D points generated, defaults to 0.0.</p></li>
<li><p><strong>t_max</strong> (<em>float</em><em>, </em><em>optional</em>) – The upper boound of the 1-D points generated, defaults to 1.0.</p></li>
<li><p><strong>method</strong> (<em>str</em><em>, </em><em>optional</em>) – The distribution of the 1-D points generated.
If set to ‘uniform’, the points will be drew from a uniform distribution Unif(t_min, t_max).
If set to ‘equally-spaced’, the points will be fixed to a set of linearly-spaced points that go from t_min to t_max.
If set to ‘equally-spaced-noisy’, a normal noise will be added to the previously mentioned set of points.
If set to ‘log-spaced’, the points will be fixed to a set of log-spaced points that go from t_min to t_max.
If set to ‘log-spaced-noisy’, a normal noise will be added to the previously mentioned set of points, defaults to ‘uniform’.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – When provided with an unknown method.</p>
</dd>
</dl>
</dd></dl>
<dl class="py class">
<dt id="neurodiffeq.generators.Generator2D"><a name="//apple_ref/cpp/Class/neurodiffeq.generators.Generator2D"></a>
<em class="property">class </em><code class="sig-prename descclassname">neurodiffeq.generators.</code><code class="sig-name descname">Generator2D</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">grid</span><span class="o">=</span><span class="default_value">10, 10</span></em>, <em class="sig-param"><span class="n">xy_min</span><span class="o">=</span><span class="default_value">0.0, 0.0</span></em>, <em class="sig-param"><span class="n">xy_max</span><span class="o">=</span><span class="default_value">1.0, 1.0</span></em>, <em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">'equally-spaced-noisy'</span></em>, <em class="sig-param"><span class="n">xy_noise_std</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.generators.Generator2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#neurodiffeq.generators.BaseGenerator" title="neurodiffeq.generators.BaseGenerator"><code class="xref py py-class docutils literal notranslate"><span class="pre">neurodiffeq.generators.BaseGenerator</span></code></a></p>
<p>An example generator for generating 2-D training points.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>grid</strong> (<em>tuple</em><em>[</em><em>int</em><em>, </em><em>int</em><em>]</em><em>, </em><em>optional</em>) – The discretization of the 2 dimensions, if we want to generate points on a <span class="math notranslate nohighlight">\(m \times n\)</span> grid, then <cite>grid</cite> is <cite>(m, n)</cite>, defaults to <cite>(10, 10)</cite>.</p></li>
<li><p><strong>xy_min</strong> (<em>tuple</em><em>[</em><em>float</em><em>, </em><em>float</em><em>]</em><em>, </em><em>optional</em>) – The lower bound of 2 dimensions, if we only care about <span class="math notranslate nohighlight">\(x \geq x_0\)</span> and <span class="math notranslate nohighlight">\(y \geq y_0\)</span>, then <cite>xy_min</cite> is <cite>(x_0, y_0)</cite>, defaults to <cite>(0.0, 0.0)</cite>.</p></li>
<li><p><strong>xy_max</strong> (<em>tuple</em><em>[</em><em>float</em><em>, </em><em>float</em><em>]</em><em>, </em><em>optional</em>) – The upper boound of 2 dimensions, if we only care about <span class="math notranslate nohighlight">\(x \leq x_1\)</span> and <span class="math notranslate nohighlight">\(y \leq y_1\)</span>, then <cite>xy_min</cite> is <cite>(x_1, y_1)</cite>, defaults to <cite>(1.0, 1.0)</cite>.</p></li>
<li><p><strong>method</strong> (<em>str</em><em>, </em><em>optional</em>) – The distribution of the 2-D points generated.
If set to ‘equally-spaced’, the points will be fixed to the grid specified.
If set to ‘equally-spaced-noisy’, a normal noise will be added to the previously mentioned set of points, defaults to ‘equally-spaced-noisy’.</p></li>
<li><p><strong>xy_noise_std</strong> (<em>tuple</em><em>[</em><em>int</em><em>, </em><em>int</em><em>]</em><em>, </em><em>optional</em><em>, </em><em>defaults to None</em>) – the standard deviation of the noise on the x and y dimension, if not specified, the default value will be (grid step size on x dimension / 4, grid step size on y dimension / 4)</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – When provided with an unknown method.</p>
</dd>
</dl>
</dd></dl>
<dl class="py class">
<dt id="neurodiffeq.generators.Generator3D"><a name="//apple_ref/cpp/Class/neurodiffeq.generators.Generator3D"></a>
<em class="property">class </em><code class="sig-prename descclassname">neurodiffeq.generators.</code><code class="sig-name descname">Generator3D</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">grid</span><span class="o">=</span><span class="default_value">10, 10, 10</span></em>, <em class="sig-param"><span class="n">xyz_min</span><span class="o">=</span><span class="default_value">0.0, 0.0, 0.0</span></em>, <em class="sig-param"><span class="n">xyz_max</span><span class="o">=</span><span class="default_value">1.0, 1.0, 1.0</span></em>, <em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">'equally-spaced-noisy'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.generators.Generator3D" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#neurodiffeq.generators.BaseGenerator" title="neurodiffeq.generators.BaseGenerator"><code class="xref py py-class docutils literal notranslate"><span class="pre">neurodiffeq.generators.BaseGenerator</span></code></a></p>
<p>An example generator for generating 3-D training points. NOT TO BE CONFUSED with <cite>GeneratorSpherical</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>grid</strong> (<em>tuple</em><em>[</em><em>int</em><em>, </em><em>int</em><em>, </em><em>int</em><em>]</em><em>, </em><em>optional</em>) – The discretization of the 3 dimensions, if we want to generate points on a <span class="math notranslate nohighlight">\(m \times n \times k\)</span> grid, then <cite>grid</cite> is <cite>(m, n, k)</cite>, defaults to <cite>(10, 10, 10)</cite>.</p></li>
<li><p><strong>xyz_min</strong> (<em>tuple</em><em>[</em><em>float</em><em>, </em><em>float</em><em>, </em><em>float</em><em>]</em><em>, </em><em>optional</em>) – The lower bound of 3 dimensions, if we only care about <span class="math notranslate nohighlight">\(x \geq x_0\)</span>, <span class="math notranslate nohighlight">\(y \geq y_0\)</span>, and <span class="math notranslate nohighlight">\(z \geq z_0\)</span> then <cite>xyz_min</cite> is <span class="math notranslate nohighlight">\((x_0, y_0, z_0)\)</span>, defaults to <cite>(0.0, 0.0, 0.0)</cite>.</p></li>
<li><p><strong>xyz_max</strong> (<em>tuple</em><em>[</em><em>float</em><em>, </em><em>float</em><em>, </em><em>float</em><em>]</em><em>, </em><em>optional</em>) – The upper bound of 3 dimensions, if we only care about <span class="math notranslate nohighlight">\(x \leq x_1\)</span>, <span class="math notranslate nohighlight">\(y \leq y_1\)</span>, and <span class="math notranslate nohighlight">\(z \leq z_1\)</span> then <cite>xyz_max</cite> is <span class="math notranslate nohighlight">\((x_1, y_1, z_1)\)</span>, defaults to <cite>(1.0, 1.0, 1.0)</cite>.</p></li>
<li><p><strong>method</strong> (<em>str</em><em>, </em><em>optional</em>) – The distribution of the 3-D points generated. If set to ‘equally-spaced’, the points will be fixed to the grid specified. If set to ‘equally-spaced-noisy’, a normal noise will be added to the previously mentioned set of points, defaults to ‘equally-spaced-noisy’.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – When provided with an unknown method.</p>
</dd>
</dl>
</dd></dl>
<dl class="py class">
<dt id="neurodiffeq.generators.GeneratorSpherical"><a name="//apple_ref/cpp/Class/neurodiffeq.generators.GeneratorSpherical"></a>
<em class="property">class </em><code class="sig-prename descclassname">neurodiffeq.generators.</code><code class="sig-name descname">GeneratorSpherical</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">size</span></em>, <em class="sig-param"><span class="n">r_min</span><span class="o">=</span><span class="default_value">0.0</span></em>, <em class="sig-param"><span class="n">r_max</span><span class="o">=</span><span class="default_value">1.0</span></em>, <em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">'equally-spaced-noisy'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.generators.GeneratorSpherical" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#neurodiffeq.generators.BaseGenerator" title="neurodiffeq.generators.BaseGenerator"><code class="xref py py-class docutils literal notranslate"><span class="pre">neurodiffeq.generators.BaseGenerator</span></code></a></p>
<p>An example generator for generating points in spherical coordinates. NOT TO BE CONFUSED with <cite>Generator3D</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>size</strong> (<em>int</em>) – number of points in 3-D sphere</p></li>
<li><p><strong>r_min</strong> (<em>float</em><em>, </em><em>optional</em>) – radius of the interior boundary</p></li>
<li><p><strong>r_max</strong> (<em>float</em><em>, </em><em>optional</em>) – radius of the exterior boundary</p></li>
<li><p><strong>method</strong> (<em>str</em><em>, </em><em>optional</em>) – The distribution of the 3-D points generated. If set to ‘equally-radius-noisy’, radius of the points will be drawn from a uniform distribution <span class="math notranslate nohighlight">\(r \sim U[r_{min}, r_{max}]\)</span>. If set to ‘equally-spaced-noisy’, squared radius of the points will be drawn from a uniform distribution <span class="math notranslate nohighlight">\(r^2 \sim U[r_{min}^2, r_{max}^2]\)</span></p></li>
</ul>
</dd>
</dl>
</dd></dl>
<dl class="py class">
<dt id="neurodiffeq.generators.PredefinedGenerator"><a name="//apple_ref/cpp/Class/neurodiffeq.generators.PredefinedGenerator"></a>
<em class="property">class </em><code class="sig-prename descclassname">neurodiffeq.generators.</code><code class="sig-name descname">PredefinedGenerator</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">xs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.generators.PredefinedGenerator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#neurodiffeq.generators.BaseGenerator" title="neurodiffeq.generators.BaseGenerator"><code class="xref py py-class docutils literal notranslate"><span class="pre">neurodiffeq.generators.BaseGenerator</span></code></a></p>
<p>A generator for generating training points. Here the training points are fixed and predefined.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xs</strong> (<cite>torch.Tensor</cite>) – The x-dimension of the trianing points</p></li>
<li><p><strong>ys</strong> (<cite>torch.Tensor</cite>) – The y-dimension of the training points</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="neurodiffeq.generators.PredefinedGenerator.get_examples"><a name="//apple_ref/cpp/Method/neurodiffeq.generators.PredefinedGenerator.get_examples"></a>
<code class="sig-name descname">get_examples</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.generators.PredefinedGenerator.get_examples" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the training points. Points are fixed and predefined.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The predefined training points</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>tuple[<cite>torch.Tensor</cite>]</p>
</dd>
</dl>
</dd></dl>
</dd></dl>
<dl class="py class">
<dt id="neurodiffeq.generators.ResampleGenerator"><a name="//apple_ref/cpp/Class/neurodiffeq.generators.ResampleGenerator"></a>
<em class="property">class </em><code class="sig-prename descclassname">neurodiffeq.generators.</code><code class="sig-name descname">ResampleGenerator</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">generator</span></em>, <em class="sig-param"><span class="n">size</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">replacement</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.generators.ResampleGenerator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#neurodiffeq.generators.BaseGenerator" title="neurodiffeq.generators.BaseGenerator"><code class="xref py py-class docutils literal notranslate"><span class="pre">neurodiffeq.generators.BaseGenerator</span></code></a></p>
<p>A generator whose output is shuffled and resampled every time</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>generator</strong> (<a class="reference internal" href="#neurodiffeq.generators.BaseGenerator" title="neurodiffeq.generators.BaseGenerator"><em>BaseGenerator</em></a>) – a generator used to generate samples to be shuffled and resampled</p></li>
<li><p><strong>size</strong> (<em>int</em>) – size of the shuffled output, defaults to the size of <cite>generator</cite></p></li>
<li><p><strong>replacement</strong> (<em>bool</em>) – whether to sample with replacement or not; defaults to False</p></li>
</ul>
</dd>
</dl>
</dd></dl>
<dl class="py class">
<dt id="neurodiffeq.generators.StaticGenerator"><a name="//apple_ref/cpp/Class/neurodiffeq.generators.StaticGenerator"></a>
<em class="property">class </em><code class="sig-prename descclassname">neurodiffeq.generators.</code><code class="sig-name descname">StaticGenerator</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">generator</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.generators.StaticGenerator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#neurodiffeq.generators.BaseGenerator" title="neurodiffeq.generators.BaseGenerator"><code class="xref py py-class docutils literal notranslate"><span class="pre">neurodiffeq.generators.BaseGenerator</span></code></a></p>
<p>A generator that returns the same samples, obtained by its sub-generator, every time</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>generator</strong> (<a class="reference internal" href="#neurodiffeq.generators.BaseGenerator" title="neurodiffeq.generators.BaseGenerator"><em>BaseGenerator</em></a>) – a generator used to generate the static samples</p>
</dd>
</dl>
</dd></dl>
<dl class="py class">
<dt id="neurodiffeq.generators.TransformGenerator"><a name="//apple_ref/cpp/Class/neurodiffeq.generators.TransformGenerator"></a>
<em class="property">class </em><code class="sig-prename descclassname">neurodiffeq.generators.</code><code class="sig-name descname">TransformGenerator</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">generator</span></em>, <em class="sig-param"><span class="n">transforms</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.generators.TransformGenerator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#neurodiffeq.generators.BaseGenerator" title="neurodiffeq.generators.BaseGenerator"><code class="xref py py-class docutils literal notranslate"><span class="pre">neurodiffeq.generators.BaseGenerator</span></code></a></p>
<p>A generator which applies certain transformations on the sample vectors</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>generator</strong> (<a class="reference internal" href="#neurodiffeq.generators.BaseGenerator" title="neurodiffeq.generators.BaseGenerator"><em>BaseGenerator</em></a>) – a generator used to generate samples on which transformations will be applied</p></li>
<li><p><strong>transforms</strong> (<em>list</em><em>[</em><em>callable</em><em>]</em>) – a list of transformations to be applied on the sample vectors; identity transformation can be replaced with None</p></li>
</ul>
</dd>
</dl>
</dd></dl>
</div>
<div class="section" id="module-neurodiffeq.operators">
<span id="neurodiffeq-operators"></span><h2><a name="//apple_ref/cpp/Module/neurodiffeq.operators"></a><cite>neurodiffeq.operators</cite><a class="headerlink" href="#module-neurodiffeq.operators" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="neurodiffeq.operators.spherical_curl"><a name="//apple_ref/cpp/Function/neurodiffeq.operators.spherical_curl"></a>
<code class="sig-prename descclassname">neurodiffeq.operators.</code><code class="sig-name descname">spherical_curl</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">u_r</span></em>, <em class="sig-param"><span class="n">u_theta</span></em>, <em class="sig-param"><span class="n">u_phi</span></em>, <em class="sig-param"><span class="n">r</span></em>, <em class="sig-param"><span class="n">theta</span></em>, <em class="sig-param"><span class="n">phi</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.operators.spherical_curl" title="Permalink to this definition">¶</a></dt>
<dd><p>Derives and evaluates the spherical curl of a spherical vector field <span class="math notranslate nohighlight">\(u\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>u_r</strong> (<cite>torch.Tensor</cite>) – The <span class="math notranslate nohighlight">\(r\)</span>-component of the vector field <span class="math notranslate nohighlight">\(u\)</span>, must have shape (n_samples, 1).</p></li>
<li><p><strong>u_theta</strong> (<cite>torch.Tensor</cite>) – The <span class="math notranslate nohighlight">\(\theta\)</span>-component of the vector field <span class="math notranslate nohighlight">\(u\)</span>, must have shape (n_samples, 1).</p></li>
<li><p><strong>u_phi</strong> (<cite>torch.Tensor</cite>) – The <span class="math notranslate nohighlight">\(\phi\)</span>-component of the vector field <span class="math notranslate nohighlight">\(u\)</span>, must have shape (n_samples, 1).</p></li>
<li><p><strong>r</strong> (<cite>torch.Tensor</cite>) – A vector of <span class="math notranslate nohighlight">\(r\)</span>-coordinate values, must have shape (n_samples, 1).</p></li>
<li><p><strong>theta</strong> (<cite>torch.Tensor</cite>) – A vector of <span class="math notranslate nohighlight">\(\theta\)</span>-coordinate values, must have shape (n_samples, 1).</p></li>
<li><p><strong>phi</strong> (<cite>torch.Tensor</cite>) – A vector of <span class="math notranslate nohighlight">\(\phi\)</span>-coordinate values, must have shape (n_samples, 1).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The <span class="math notranslate nohighlight">\(r\)</span>, <span class="math notranslate nohighlight">\(\theta\)</span>, and <span class="math notranslate nohighlight">\(\phi\)</span> components of the curl, each with shape (n_samples, 1).</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tuple[<cite>torch.Tensor</cite>]</p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt id="neurodiffeq.operators.spherical_div"><a name="//apple_ref/cpp/Function/neurodiffeq.operators.spherical_div"></a>
<code class="sig-prename descclassname">neurodiffeq.operators.</code><code class="sig-name descname">spherical_div</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">u_r</span></em>, <em class="sig-param"><span class="n">u_theta</span></em>, <em class="sig-param"><span class="n">u_phi</span></em>, <em class="sig-param"><span class="n">r</span></em>, <em class="sig-param"><span class="n">theta</span></em>, <em class="sig-param"><span class="n">phi</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.operators.spherical_div" title="Permalink to this definition">¶</a></dt>
<dd><p>Derives and evaluates the spherical divergence of a spherical vector field <span class="math notranslate nohighlight">\(u\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>u_r</strong> (<cite>torch.Tensor</cite>) – The <span class="math notranslate nohighlight">\(r\)</span>-component of the vector field <span class="math notranslate nohighlight">\(u\)</span>, must have shape (n_samples, 1).</p></li>
<li><p><strong>u_theta</strong> (<cite>torch.Tensor</cite>) – The <span class="math notranslate nohighlight">\(\theta\)</span>-component of the vector field <span class="math notranslate nohighlight">\(u\)</span>, must have shape (n_samples, 1).</p></li>
<li><p><strong>u_phi</strong> (<cite>torch.Tensor</cite>) – The <span class="math notranslate nohighlight">\(\phi\)</span>-component of the vector field <span class="math notranslate nohighlight">\(u\)</span>, must have shape (n_samples, 1).</p></li>
<li><p><strong>r</strong> (<cite>torch.Tensor</cite>) – A vector of <span class="math notranslate nohighlight">\(r\)</span>-coordinate values, must have shape (n_samples, 1).</p></li>
<li><p><strong>theta</strong> (<cite>torch.Tensor</cite>) – A vector of <span class="math notranslate nohighlight">\(\theta\)</span>-coordinate values, must have shape (n_samples, 1).</p></li>
<li><p><strong>phi</strong> (<cite>torch.Tensor</cite>) – A vector of <span class="math notranslate nohighlight">\(\phi\)</span>-coordinate values, must have shape (n_samples, 1).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The divergence evaluated at <span class="math notranslate nohighlight">\((r, \theta, \phi)\)</span>, with shape (n_samples, 1).</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>torch.Tensor</cite></p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt id="neurodiffeq.operators.spherical_grad"><a name="//apple_ref/cpp/Function/neurodiffeq.operators.spherical_grad"></a>
<code class="sig-prename descclassname">neurodiffeq.operators.</code><code class="sig-name descname">spherical_grad</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">u</span></em>, <em class="sig-param"><span class="n">r</span></em>, <em class="sig-param"><span class="n">theta</span></em>, <em class="sig-param"><span class="n">phi</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.operators.spherical_grad" title="Permalink to this definition">¶</a></dt>
<dd><p>Derives and evaluates the spherical gradient of a spherical scalar field <span class="math notranslate nohighlight">\(u\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>u</strong> (<cite>torch.Tensor</cite>) – A scalar field <span class="math notranslate nohighlight">\(u\)</span>, must have shape (n_samples, 1).</p></li>
<li><p><strong>r</strong> (<cite>torch.Tensor</cite>) – A vector of <span class="math notranslate nohighlight">\(r\)</span>-coordinate values, must have shape (n_samples, 1).</p></li>
<li><p><strong>theta</strong> (<cite>torch.Tensor</cite>) – A vector of <span class="math notranslate nohighlight">\(\theta\)</span>-coordinate values, must have shape (n_samples, 1).</p></li>
<li><p><strong>phi</strong> (<cite>torch.Tensor</cite>) – A vector of <span class="math notranslate nohighlight">\(\phi\)</span>-coordinate values, must have shape (n_samples, 1).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The <span class="math notranslate nohighlight">\(r\)</span>, <span class="math notranslate nohighlight">\(\theta\)</span>, and <span class="math notranslate nohighlight">\(\phi\)</span> components of the gradient, each with shape (n_samples, 1).</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tuple[<cite>torch.Tensor</cite>]</p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt id="neurodiffeq.operators.spherical_laplacian"><a name="//apple_ref/cpp/Function/neurodiffeq.operators.spherical_laplacian"></a>
<code class="sig-prename descclassname">neurodiffeq.operators.</code><code class="sig-name descname">spherical_laplacian</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">u</span></em>, <em class="sig-param"><span class="n">r</span></em>, <em class="sig-param"><span class="n">theta</span></em>, <em class="sig-param"><span class="n">phi</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.operators.spherical_laplacian" title="Permalink to this definition">¶</a></dt>
<dd><p>Derives and evaluates the spherical laplacian of a spherical scalar field <span class="math notranslate nohighlight">\(u\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>u</strong> (<cite>torch.Tensor</cite>) – A scalar field <span class="math notranslate nohighlight">\(u\)</span>, must have shape (n_samples, 1).</p></li>
<li><p><strong>r</strong> (<cite>torch.Tensor</cite>) – A vector of <span class="math notranslate nohighlight">\(r\)</span>-coordinate values, must have shape (n_samples, 1).</p></li>
<li><p><strong>theta</strong> (<cite>torch.Tensor</cite>) – A vector of <span class="math notranslate nohighlight">\(\theta\)</span>-coordinate values, must have shape (n_samples, 1).</p></li>
<li><p><strong>phi</strong> (<cite>torch.Tensor</cite>) – A vector of <span class="math notranslate nohighlight">\(\phi\)</span>-coordinate values, must have shape (n_samples, 1).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The laplacian evaluated at <span class="math notranslate nohighlight">\((r, \theta, \phi)\)</span>, with shape (n_samples, 1).</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>torch.Tensor</cite></p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt id="neurodiffeq.operators.spherical_vector_laplacian"><a name="//apple_ref/cpp/Function/neurodiffeq.operators.spherical_vector_laplacian"></a>
<code class="sig-prename descclassname">neurodiffeq.operators.</code><code class="sig-name descname">spherical_vector_laplacian</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">u_r</span></em>, <em class="sig-param"><span class="n">u_theta</span></em>, <em class="sig-param"><span class="n">u_phi</span></em>, <em class="sig-param"><span class="n">r</span></em>, <em class="sig-param"><span class="n">theta</span></em>, <em class="sig-param"><span class="n">phi</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.operators.spherical_vector_laplacian" title="Permalink to this definition">¶</a></dt>
<dd><p>Derives and evaluates the spherical laplacian of a spherical vector field <span class="math notranslate nohighlight">\(u\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>u_r</strong> (<cite>torch.Tensor</cite>) – The <span class="math notranslate nohighlight">\(r\)</span>-component of the vector field <span class="math notranslate nohighlight">\(u\)</span>, must have shape (n_samples, 1).</p></li>
<li><p><strong>u_theta</strong> (<cite>torch.Tensor</cite>) – The <span class="math notranslate nohighlight">\(\theta\)</span>-component of the vector field <span class="math notranslate nohighlight">\(u\)</span>, must have shape (n_samples, 1).</p></li>
<li><p><strong>u_phi</strong> (<cite>torch.Tensor</cite>) – The <span class="math notranslate nohighlight">\(\phi\)</span>-component of the vector field <span class="math notranslate nohighlight">\(u\)</span>, must have shape (n_samples, 1).</p></li>
<li><p><strong>r</strong> (<cite>torch.Tensor</cite>) – A vector of <span class="math notranslate nohighlight">\(r\)</span>-coordinate values, must have shape (n_samples, 1).</p></li>
<li><p><strong>theta</strong> (<cite>torch.Tensor</cite>) – A vector of <span class="math notranslate nohighlight">\(\theta\)</span>-coordinate values, must have shape (n_samples, 1).</p></li>
<li><p><strong>phi</strong> (<cite>torch.Tensor</cite>) – A vector of <span class="math notranslate nohighlight">\(\phi\)</span>-coordinate values, must have shape (n_samples, 1).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The laplacian evaluated at <span class="math notranslate nohighlight">\((r, \theta, \phi)\)</span>, with shape (n_samples, 1).</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>torch.Tensor</cite></p>
</dd>
</dl>
</dd></dl>
</div>
<div class="section" id="module-neurodiffeq.utils">
<span id="neurodiffeq-utils"></span><h2><a name="//apple_ref/cpp/Module/neurodiffeq.utils"></a><cite>neurodiffeq.utils</cite><a class="headerlink" href="#module-neurodiffeq.utils" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="neurodiffeq.utils.set_tensor_type"><a name="//apple_ref/cpp/Function/neurodiffeq.utils.set_tensor_type"></a>
<code class="sig-prename descclassname">neurodiffeq.utils.</code><code class="sig-name descname">set_tensor_type</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">device</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">float_bits</span><span class="o">=</span><span class="default_value">32</span></em><span class="sig-paren">)</span><a class="headerlink" href="#neurodiffeq.utils.set_tensor_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the default torch tensor type to be used with neurodiffeq.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>device</strong> (<em>str</em>) – Either “cpu” or “cuda” (“gpu”); defaults to “cuda” if available.</p></li>
<li><p><strong>float_bits</strong> (<em>int</em>) – Length of float numbers. Either 32 (float) or 64 (double); defaults to 32.</p></li>
</ul>
</dd>
</dl>
</dd></dl>
</div>
</div>
</div>
</div>
<footer>
<div aria-label="footer navigation" class="rst-footer-buttons" role="navigation">
<a accesskey="n" class="btn btn-neutral float-right" href="how.html" rel="next" title="How Does It Work?">Next <span class="fa fa-arrow-circle-right"></span></a>
<a accesskey="p" class="btn btn-neutral float-left" href="advanced.html" rel="prev" title="Advanced Uses"><span class="fa fa-arrow-circle-left"></span> Previous</a>
</div>
<hr/>
<div role="contentinfo">
<p>
        
        © Copyright 2019, odegym

    </p>
</div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
</div>
</div>
</section>
</div>
<script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
</body>
</html>